# A0130369H
###### \src\common\CommandType.java
``` java
package common;

public enum CommandType {
	ADD, UPDATE, DELETE, CLEAR, TICK, ERROR, EXIT, SEARCH, UNDO, REDO, UNDEFINED, DETAIL, CHANGEMODE, UNTICK, CONFIG, HELP;
}
```
###### \src\common\Constant.java
``` java
package common;

public class Constant {
		
		// List of all available error values for the parsedCommand
		public static final String VALUE_ERROR_NO_ERROR = "Success";
		public static final String VALUE_ERROR_COMMAND_NOT_FOUND = "Invalid command. Check your command again?";
		public static final String VALUE_ERROR_NO_INPUT = "Empty input";
		public static final String VALUE_ERROR_INVALID_ARGUMENT = "Invalid argument";
		public static final String VALUE_ERROR_ADD_EMPTY = "What do you want to add?";
		public static final String VALUE_ERROR_SEARCH_EMPTY = "What do you want to search?";
		public static final String VALUE_ERROR_UPDATE_WRONG_ARGUMENT = "Your input seems wrong. You may type Help for input format";
		public static final String VALUE_ERROR_INVALID_VIEW_MODE = "We do not have that view mode. Try again?";
		public static final String VALUE_ERROR_INVALID_CONFIG = "We do not have that font or themes. Check for any typos?";
		public static final String VALUE_ERROR_ARGUMENT_NOT_EMPTY = "This command has no argument, remember?";
		public static final String VALUE_ERROR_ARGUMENT_NOT_NUMBER = "Do you put the index correctly?";
		public static final String VALUE_ERROR_DATE_NOT_PARSED = "Wrong date format?";
		public static final String VALUE_ERROR_DATE_ERROR = "Oops, starting date can't be later than end date";
		public static final String VALUE_DEFAULT_EMPTY = "";
		public static final int VALUE_DEFAULT_POSITION_INDEX = 1;
		public static final boolean VALUE_DEFAULT_BOOLEAN_TRUE = true;
		public static final boolean VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_DETAIL_DISPLAYED = true;
		public static final boolean VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_IMPORTANT = false;
		public static final boolean VALUE_DEFAULT_BOOLEAN_FALSE = false;
		public static final ViewMode VALUE_DEFAULT_VIEW_MODE = ViewMode.START;
		
		//Setting displaying message
		public static final String CONFIG_INTRO = "Welcome to Wallist Setting";
		public static final String CONFIG_DIR = "1. To change the Storage Directory, input the absolute path\n" +
												"	  Current Directory: %s\n" + 
												"(E.g. for Mac user, input: /Users/username/folder/subfolder,\n" +
												"for Windows users, input: C:\\Users\\username\\folder)";
		public static final String CONFIG_THEME = "2. To change the theme, input the theme name: (E.g. input: theme autumn)";
		public static final String CONFIG_FONT = "3. To change the font, input the font name: (E.g. input: font segoe)";
		
```
###### \src\common\TaskType.java
``` java
package common;

public enum TaskType {
	FLOATING, DEADLINE, RECURRENT, UNDEFINED
}
```
###### \src\common\TimeParser.java
``` java
package common;

import com.joestelmach.natty.*;

import java.util.Calendar;
import java.util.Date;
import java.util.List;


public class TimeParser{
 private static com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
 
 public static Date stringToDate(String str){
	 try {
		 Date current = getCurrentDate();
		 List<DateGroup> groups = dateParser.parse(str);
		 Date date = groups.get(0).getDates().get(0);
		 Calendar cal = Calendar.getInstance();
		 Calendar calCurrent = Calendar.getInstance();
		 cal.setTime(date);
		 calCurrent.setTime(current);
		 if(cal.get(Calendar.HOUR_OF_DAY) == calCurrent.get(Calendar.HOUR_OF_DAY) && cal.get(Calendar.MINUTE) == calCurrent.get(Calendar.MINUTE)){
			 cal.set(Calendar.HOUR_OF_DAY, 23);
			 cal.set(Calendar.MINUTE, 59);
			 cal.set(Calendar.SECOND, 59);
		 }
		 
		 
		 return cal.getTime();
	 } catch (Exception e){
		 return null;
	 }
 }
 
 public static Date getCurrentDate(){
	 return Calendar.getInstance().getTime();
 }
}


```
###### \src\parser\Command.java
``` java
package parser;

import common.State;
import common.TaskType;
import common.ViewMode;

import java.util.ArrayList;
import java.util.Date;

interface Command {
	//====================================
	//       Public Functions
	//====================================
	public void processInput();
		
	default String getContentWithoutCommand(State state){
		String inputWords[] = state.getUserInput().split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
}
```
###### \src\parser\CommandAdd.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.TimeParser;
import common.ViewMode;

public class CommandAdd implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandAdd(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		String wordList[] = content_.split("detail:");
		if(wordList.length <= 1){
			state_.setIsDetailChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListVenue[] = wordList[wordList.length-1].split("at:");
			if(wordListVenue.length <= 1){
				state_.setIsDetailChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				state_.setIsDetailChanged(true);
				return wordListVenue[0].trim();
			}
		}
	}

	 
	private String getVenue() {
		String wordList[] = content_.split("at:");
		if(wordList.length <= 1){
			state_.setIsVenueChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListDetails[] = wordList[wordList.length-1].split("detail:");
			if(wordListDetails.length <= 1){
				state_.setIsVenueChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				state_.setIsVenueChanged(true);
				return wordListDetails[0].trim();
			}
		}
	}

	 
	private Date getStartDate() {
		String wordList[] = content_.split("from:");
		if(wordList.length==1){
			state_.setIsStartDateChanged(false);
			return null;
		}
		String endDate = wordList[wordList.length-1].trim();
		String wordListEnd[] = endDate.split("to:");
		
		if(wordListEnd.length<=1){
			state_.setIsStartDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
		Date date = TimeParser.stringToDate(wordListEnd[0].trim());
		if(date != null){
			state_.setIsStartDateChanged(true);
			return date;
		}else{
			state_.setIsStartDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	 
	private Date getEndDate() {
		if(state_.getIsStartDateChanged()){
			String wordList[] = content_.split("to:");
			if(wordList.length==1){
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
			Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
			if(date != null){
				state_.setIsEndDateChanged(true);
				if(date.before(state_.getStartDate())){
					state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_ERROR);
					state_.setIsValid(false);
					state_.setIsEndDateChanged(false);
					state_.setIsStartDateChanged(false);
					return null;
				}
				return date;
			}else{
				state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
				state_.setIsValid(false);
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
		}
		String wordList[] = content_.split("on:");
		if(wordList.length==1){
			state_.setIsEndDateChanged(false);
			return null;
		}
		Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
		if(date != null){
			state_.setIsEndDateChanged(true);
			return date;
		}else{
			state_.setIsEndDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		if(state_.getIsStartDateChanged()){
			String wordList[] = content_.split("from:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsEndDateChanged()){
			String wordList[] = content_.split("on:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsVenueChanged()){
			String wordList[] = content_.split("at:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsDetailChanged()){
				String wordListDetail[] = wordList[0].split("detail:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListDetail[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else if(state_.getIsDetailChanged()){
			String wordList[] = content_.split("detail:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsVenueChanged()){
				String wordListVenue[] = wordList[0].split("at:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListVenue[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else{
			state_.setIsContentChanged(true);
			return content_;
		}
	}


	 
	private TaskType getTaskType() {
		if(state_.getIsEndDateChanged()){
			return TaskType.DEADLINE;
		}else{
			return TaskType.FLOATING;
		}
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
	
}
```
###### \src\parser\CommandChangeMode.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandChangeMode implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandChangeMode(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		ViewMode viewMode = determineViewMode();
		return viewMode;
	}
	
	/**
	 * Get the view mode based on content
	 * @return ViewMode
	 */
	private ViewMode determineViewMode() {
		if(content_.equalsIgnoreCase("FLOATING")){
			return ViewMode.FLOATING;
		} else if(content_.equalsIgnoreCase("SCHEDULED")){
			return ViewMode.DEADLINE;
		} else if(content_.equalsIgnoreCase("ALL")){
			return ViewMode.ALL;
		} else if(content_.equalsIgnoreCase("SETTING")){
			return ViewMode.CONFIG;
		} else if(content_.equalsIgnoreCase("FINISHED")){
			return ViewMode.FINISHED;
		} else if (content_.equalsIgnoreCase("HELP")) {
			return ViewMode.HELP;
		} else if (content_.equalsIgnoreCase("TODAY")) {
			return ViewMode.START;
		} else {
			return ViewMode.UNDEFINED;
		}
	}
}
```
###### \src\parser\CommandClear.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandClear implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandClear(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \src\parser\CommandConfig.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.Font;
import common.State;
import common.TaskType;
import common.Theme;
import common.ViewMode;

public class CommandConfig implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandConfig(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		state_.setNewFont(getFont());
		state_.setNewTheme(getTheme());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(true);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.CONFIG;
	}
	
	private Theme getTheme() {
		if(content_.equalsIgnoreCase("autumn")){
			return Theme.AUTUMN;
		}else if(content_.equalsIgnoreCase("bokeh")){
			return Theme.BOKEH;
		}else if(content_.equalsIgnoreCase("branch")){
			return Theme.BRANCH;
		}else if(content_.equalsIgnoreCase("cat")){
			return Theme.CAT;
		}else if(content_.equalsIgnoreCase("grey")){
			return Theme.GREY;
		}else if(content_.equalsIgnoreCase("warm")){
			return Theme.WARM;
		}else{
			return state_.getTheme();
		}
	}
	private Font getFont() {
		if(content_.equalsIgnoreCase("consolas")){
			return Font.CONSOLAS;
		}else if(content_.equalsIgnoreCase("segoe")){
			return Font.SEGOE;
		}else{
			return state_.getFont();
		}
	}

}
```
###### \src\parser\CommandDelete.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandDelete implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandDelete(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandDetail.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandDetail implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandDetail(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandHelp.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandHelp implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandHelp(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.HELP;
	}

}
```
###### \src\parser\CommandRedo.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandRedo implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandRedo(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \src\parser\CommandSearch.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandSearch implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandSearch(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		ArrayList<String> keywords = new ArrayList<String>();
		String inputKeyWords[] = content_.split(" ");
		if(inputKeyWords.length == 0){
			state_.setDisplayMessage(Constant.VALUE_ERROR_SEARCH_EMPTY);
		}
		for(int i = 0; i<inputKeyWords.length; i++){
			keywords.add(inputKeyWords[i]);
		}
		return keywords;
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.SEARCH;
	}

}
```
###### \src\parser\CommandTick.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandTick implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandTick(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandUndo.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandUndo implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandUndo(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandUntick.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandUntick implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandUntick(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandUpdate.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.TimeParser;
import common.ViewMode;

public class CommandUpdate implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandUpdate(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		String content = getContentWithoutIndex();
		String wordList[] = content.split("detail:");
		if(wordList.length <= 1){
			state_.setIsDetailChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListVenue[] = wordList[wordList.length-1].split("at:");
			if(wordListVenue.length <= 1){
				state_.setIsDetailChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				state_.setIsDetailChanged(true);
				return wordListVenue[0].trim();
			}
		}
	}

	 
	private String getVenue() {
		String content = getContentWithoutIndex();
		String wordList[] = content.split("at:");
		if(wordList.length <= 1){
			state_.setIsVenueChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListDetails[] = wordList[wordList.length-1].split("detail:");
			if(wordListDetails.length <= 1){
				state_.setIsVenueChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				state_.setIsVenueChanged(true);
				return wordListDetails[0].trim();
			}
		}
	}

	 
	private Date getStartDate() {
		String wordList[] = content_.split("from:");
		if(wordList.length<=1){
			state_.setIsStartDateChanged(false);
			return null;
		}
		String endDate = wordList[wordList.length-1].trim();
		String wordListEnd[] = endDate.split("to:");
		
		if(wordListEnd.length<=1){
			state_.setIsStartDateChanged(false);
			state_.setIsValid(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			return null;
		}
		Date date = TimeParser.stringToDate(wordListEnd[0].trim());
		if(date != null){
			state_.setIsStartDateChanged(true);
			return date;
		}else{
			state_.setIsStartDateChanged(false);
			state_.setIsValid(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			return null;
		}
	}

	 
	private Date getEndDate() {
		if(state_.getIsStartDateChanged()){
			String wordList[] = content_.split("to:");
			if(wordList.length<=1){
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
			Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
			if(date != null){
				state_.setIsEndDateChanged(true);
				if(date.before(state_.getStartDate())){
					state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_ERROR);
					state_.setIsValid(false);
					state_.setIsEndDateChanged(false);
					state_.setIsStartDateChanged(false);
					return null;
				}
				return date;
			}else{
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
				state_.setIsValid(false);
				return null;
			}
		}
		String wordList[] = content_.split("on:");
		if(wordList.length<=1){
			state_.setIsEndDateChanged(false);
			return null;
		}
		Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
		if(date != null){
			state_.setIsEndDateChanged(true);
			return date;
		}else{
			state_.setIsEndDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	 
	private int getPositionIndex() {
		String wordList[] = content_.split(" ");
		return Integer.parseInt(wordList[0]);
	}

	 
	private String getContent() {
		String content = getContentWithoutIndex().trim();
		if(state_.getIsStartDateChanged()){
			String wordList[] = content.split("from:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsEndDateChanged()){
			String wordList[] = content.split("on:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsVenueChanged()){
			String wordList[] = content.split("at:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsDetailChanged()){
				String wordListDetail[] = wordList[0].split("detail:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListDetail[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else if(state_.getIsDetailChanged()){
			String wordList[] = content.split("detail:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsVenueChanged()){
				String wordListVenue[] = wordList[0].split("at:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListVenue[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else{
			if(content.trim().isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
			}
			state_.setIsContentChanged(true);
			return content;
		}
	}

	private String getContentWithoutIndex() {
		String inputWords[] = content_.split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
	
	 
	private TaskType getTaskType() {
		if(state_.getIsEndDateChanged()){
			return TaskType.DEADLINE;
		}else{
			return TaskType.FLOATING;
		}
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \src\parser\Parser.java
``` java
package parser;

import common.*;

public class Parser {
	
	//============================
	//       Attributes
	//============================
	
	private State state_;
	private ParserErrorChecker errorChecker_;
	private CommandAdd add_;
	private CommandChangeMode changeMode_;
	private CommandClear clear_;
	private CommandDelete delete_;
	private CommandDetail detail_;
	private CommandExit exit_;
	private CommandRedo redo_;
	private CommandSearch search_;
	private CommandTick tick_;
	private CommandUndo undo_;
	private CommandUpdate update_;
	private CommandHelp help_;
	private CommandUntick untick_;
	private CommandConfig config_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	
 	public Parser(State state){
		state_ = state;
		errorChecker_ = new ParserErrorChecker(state);
		add_ = new CommandAdd(state);
		changeMode_ = new CommandChangeMode(state);
		clear_ = new CommandClear(state);
		delete_ = new CommandDelete(state);
		detail_ = new CommandDetail(state);
		exit_ = new CommandExit(state);
		redo_ = new CommandRedo(state);
		search_ = new CommandSearch(state);
		tick_ = new CommandTick(state);
		undo_ = new CommandUndo(state);
		update_ = new CommandUpdate(state);
		help_ = new CommandHelp(state);
		config_= new CommandConfig(state);
		untick_ = new CommandUntick(state);
		
	}
	
	/**
	 * Break down a string of input into smaller parts for logic to process
	 * Pre-Cond: Input of the user in the state
	 * Post-Cond: Respective command function will process the input
	 */
	public boolean processInput(){
		errorChecker_.checkError();
		if(state_.getIsValid()){
			CommandType command = state_.getCommandType();
			System.out.println(command.toString());
			switch(command){
			case ADD:
				add_.processInput();
				break;
			case CHANGEMODE:
				changeMode_.processInput();
				break;
			case CLEAR:
				clear_.processInput();
				break;
			case DELETE:
				delete_.processInput();
				break;
			case DETAIL:
				detail_.processInput();
				break;	
			case EXIT:
				exit_.processInput();
				break;
			case REDO:
				redo_.processInput();
				break;				
			case SEARCH:
				search_.processInput();
				break;				
			case TICK:
				tick_.processInput();
				break;			
			case UNDO:
    			undo_.processInput();
				break;				
			case UPDATE:
				update_.processInput();
				break;			
			case HELP:
	    		help_.processInput();
				break;				
			case UNTICK:
				untick_.processInput();
				break;					
			case CONFIG:;
				config_.processInput();
				break;
			}		
		}
		return state_.getIsValid();
	}
}
```
###### \src\parser\ParserErrorChecker.java
``` java
package parser;

import common.CommandType;
import common.Constant;
import common.State;

public class ParserErrorChecker {
	
	//============================
	//       Attributes
	//============================
	private State state_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	public ParserErrorChecker(State state){
		state_ = state;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Check whether the content of the input has any error
	 * @return display message
	 * @return the validity of the input
	 */
	public void checkError(){
		state_.setDisplayMessage(getErrorMessage());
		state_.setIsValid(getIsValid());
		if(state_.getIsValid()){
			state_.setCommandType(getCommand());
		}
	}
	
	//====================================
	//       Helper Functions
	//====================================
	/**
	 * Check whether parsed command is valid
	 * @return True if the input is valid
	 */
	private boolean getIsValid() {
		return state_.getDisplayMessage().equals(Constant.VALUE_ERROR_NO_ERROR);
	}
	
	/**
	 * Get the error message for a given input. 
	 * @return The respective error message
	 */
	private String getErrorMessage() {
		if(isInputEmpty()){
			return Constant.VALUE_ERROR_NO_INPUT;
		}
		if(isCommandInvalid()){
			return Constant.VALUE_ERROR_COMMAND_NOT_FOUND;
		}
		return checkInvalidArgument();
	}

	/**
	 * Check whether the input is an empty string
	 * @return True if it's empty input
	 */	
	private boolean isInputEmpty() {
		return state_.getUserInput().length() == 0;
	}
	
	/**
	 * Check whether the input has a valid command (add, update, tick, delete, clear, exit, etc)
	 * @return True if the command is invalid
	 */
	private boolean isCommandInvalid() {
		if(!isInputEmpty()){
			CommandType commandType = getCommand();
			switch(commandType) {
				case ADD:
					return false;
					
				case CLEAR:
					return false;
					
				case DELETE:
					return false;
					
				case TICK:
					return false;	
					
				case UPDATE:
					return false;
					
				case EXIT:
					return false;
					
				case UNDO:
					return false;
				
				case REDO:
					return false;
					
				case CHANGEMODE:
					return false;	
					
				case SEARCH: 
					return false;
				
				case DETAIL:
					return false;
					
				case HELP:
					return false;

				case UNTICK:
					return false;
				
				case CONFIG:
					return false;
					
				default: 
					return true;
			}
		}
		return false;
	}
	
	/**
	 * Check whether the input has the correct and valid argument for the given command
	 * @return respective error message
	 */
	private String checkInvalidArgument() {
		if(!isCommandInvalid()){
			CommandType commandType = getCommand();
			String content = getContentWithoutCommand();
			try{
				switch(commandType){
				
					case ADD:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_ADD_EMPTY;
						}
						return Constant.VALUE_ERROR_NO_ERROR;
					
					case CLEAR:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
				
					case DELETE:
						if(isContentNumber(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
				
					case EXIT:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
					
					case UNDO:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
					
					case REDO:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
						
					case SEARCH:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_SEARCH_EMPTY;
						}
						return Constant.VALUE_ERROR_NO_ERROR;
						
					case TICK:
						if(isContentNumber(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
					
					case UPDATE:
						String inputWords[] = content.split(" ");
						if(!isContentNumber(inputWords[0]) || isContentEmpty(content) || hasContentOneArgument(inputWords)){
							return Constant.VALUE_ERROR_UPDATE_WRONG_ARGUMENT;
						}
						return Constant.VALUE_ERROR_NO_ERROR;
					
					case DETAIL:
						if(isContentNumber(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
					
					case CHANGEMODE:
						if(isContentValidViewMode(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_INVALID_VIEW_MODE;
					
					case HELP:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
					
					case CONFIG:
						if(isContentValidFontOrTheme(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}else{
							return Constant.VALUE_ERROR_INVALID_CONFIG;
						}
					case UNTICK:
						if(isContentNumber(content)){
							return Constant.VALUE_ERROR_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
						
					default: 
						return Constant.VALUE_ERROR_NO_ERROR;
				}
			}
			catch(IllegalArgumentException e){
				return Constant.VALUE_ERROR_INVALID_ARGUMENT;
			}
		}else{
			return Constant.VALUE_ERROR_COMMAND_NOT_FOUND;
		}
	}
	
	/**
	 * Check if content is a valid theme or font
	 * @return True if it is
	 */
	private boolean isContentValidFontOrTheme(String content) {
		return content.equalsIgnoreCase("CONSOLAS") || content.equalsIgnoreCase("SEGOE")
			|| content.equalsIgnoreCase("AUTUMN") || content.equalsIgnoreCase("BOKEH")
			|| content.equalsIgnoreCase("BRANCH") || content.equalsIgnoreCase("CAT")
			|| content.equalsIgnoreCase("GREY") || content.equalsIgnoreCase("WARM");
	}
	
	/**
	 * Check if the content is a valid viewmode
	 * @return True if it is
	 */
	private boolean isContentValidViewMode(String content) {
		return content.equalsIgnoreCase("FLOATING") || content.equalsIgnoreCase("SCHEDULED") 
				|| content.equalsIgnoreCase("ALL") || content.equalsIgnoreCase("FINISHED") 
				|| content.equalsIgnoreCase("SETTING") || content.equalsIgnoreCase("TODAY");
	}
	
	/**
	 * Check whether the content has the required index and update content
	 * @return true if it has one argument only
	 */
	private boolean hasContentOneArgument(String[] inputWords) {
		return inputWords.length ==1;
	}
	
	/**
	 * Check if the content is a number
	 * @return true if it is
	 */
	private boolean isContentNumber(String content) {
		return content.matches("\\d+");
	}

	/**
	 * Check whether the content is empty
	 * @return true if it is empty
	 */
	private boolean isContentEmpty(String content) {
		return content.isEmpty();
	}


	/**
	 * Get the content of user input without the command word
	 * @return the user input without the command word
	 */
	private String getContentWithoutCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
	/**
	 * Get the command of an input
	 * @param Input of the user
	 * @return The command type
	 */
	private CommandType getCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		return determineCommandType(inputWords[0]);
	}

	
	/**
	 * Get the command type based on input
	 * @param String of the command
	 * @return CommandType of the command
	 */
	private CommandType determineCommandType(String commandTypeString) {
		if (commandTypeString == null) {
			throw new Error("Command type string cannot be null!");
		}
		
		if (commandTypeString.equalsIgnoreCase("add")) {
			return CommandType.ADD;
		} else if (commandTypeString.equalsIgnoreCase("delete")) {
			return CommandType.DELETE;
		} else if (commandTypeString.equalsIgnoreCase("update")) {
			return CommandType.UPDATE;
		} else if (commandTypeString.equalsIgnoreCase("clear")) {
			return CommandType.CLEAR;
		} else if (commandTypeString.equalsIgnoreCase("tick")) {
			return CommandType.TICK;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return CommandType.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return CommandType.REDO;
		} else if (commandTypeString.equalsIgnoreCase("search")) {
			return CommandType.SEARCH;
		} else if (commandTypeString.equalsIgnoreCase("exit")) {
			return CommandType.EXIT;
		}  else if (commandTypeString.equalsIgnoreCase("help")) {
			return CommandType.HELP;
		}  else if (commandTypeString.equalsIgnoreCase("untick")) {
			return CommandType.UNTICK;
		} else if (commandTypeString.equalsIgnoreCase("setting")) {
			return CommandType.CONFIG;
		}else if (commandTypeString.equalsIgnoreCase("view")) {
			return getViewCommand();
		}
		return CommandType.ERROR;
	}
	
	/**
	 * Check whether it is a detail command or a changemode command
	 */
	private CommandType getViewCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		String argument = inputWords[1];
		if(isContentNumber(argument)){
			return CommandType.DETAIL;
		}else{
			return CommandType.CHANGEMODE;
		}
	}
}
```
