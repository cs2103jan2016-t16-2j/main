# A0130369H
###### \src\common\CommandType.java
``` java
package common;

public enum CommandType {
	ADD, UPDATE, DELETE, CLEAR, TICK, ERROR, EXIT, SEARCH, UNDO, REDO, UNDEFINED, DETAIL, CHANGEMODE, UNTICK, CONFIG, HELP;
}
```
###### \src\common\Constant.java
``` java
package common;

public class Constant {
		
		// List of all available error values for the parsedCommand
		public static final String VALUE_ERROR_NO_ERROR = "Success";
		public static final String VALUE_ERROR_COMMAND_NOT_FOUND = "Invalid command";
		public static final String VALUE_ERROR_NO_INPUT = "Empty input";
		public static final String VALUE_ERROR_INVALID_ARGUMENT = "Invalid argument";
		public static final String VALUE_ERROR_DATE_NOT_PARSED = "Wrong date format?";
		public static final String VALUE_ERROR_DATE_ERROR = "Oops, starting date can't be later than end date";
		public static final String VALUE_DEFAULT_EMPTY = "";
		public static final int VALUE_DEFAULT_POSITION_INDEX = 1;
		public static final boolean VALUE_DEFAULT_BOOLEAN_TRUE = true;
		public static final boolean VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_DETAIL_DISPLAYED = true;
		public static final boolean VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_IMPORTANT = false;
		public static final boolean VALUE_DEFAULT_BOOLEAN_FALSE = false;
		public static final ViewMode VALUE_DEFAULT_VIEW_MODE = ViewMode.START;
		
		//Cofiguration displaying message
		public static final String CONFIG_INTRO = "Welcome to the Configuration Mode";
		public static final String CONFIG_DIR = "1. To change the Storage Directory, input the absolute path\n" +
												"	    Current Directory: %s\n" + 
												"(E.g. for Mac user, input: /Users/username/folder/subfolder, " +
												"for Windows users, input: C:\\Users\\username\\folder)";
		public static final String CONFIG_THEME = "2. To change the theme, input the theme name: (E.g. input: theme autumn)";
		public static final String CONFIG_FONT = "3. To change the font, input the font name: (E.g. input: font segoe)";
		
```
###### \src\common\TaskType.java
``` java
package common;

public enum TaskType {
	FLOATING, DEADLINE, RECURRENT, UNDEFINED
}
```
###### \src\parser\Command.java
``` java
package parser;

import common.State;
import common.TaskType;
import common.ViewMode;

import java.util.ArrayList;
import java.util.Date;

interface Command {
	public void processInput();
	public String getDetail();
	public String getVenue();
	public Date getStartDate();
	public Date getEndDate();
	public int getPositionIndex();
	public String getContent();
	public TaskType getTaskType();
	public ArrayList<String> getSearchKey();
	public ViewMode getNewViewMode();
	
	public default String getContentWithoutCommand(State state){
		String inputWords[] = state.getUserInput().split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
}
```
###### \src\parser\CommandAdd.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandAdd implements Command{
	private State state_;
	private String content_;
	
	public CommandAdd(State state){
		this.state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		String wordList[] = content_.split("details:");
		if(wordList.length <= 1){
			state_.setIsDetailChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListVenue[] = wordList[wordList.length-1].split("at:");
			if(wordListVenue.length <= 1){
				System.out.println("HIHI");
				state_.setIsDetailChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				System.out.println("HUHU");
				state_.setIsDetailChanged(true);
				return wordListVenue[0].trim();
			}
		}
	}

	@Override
	public String getVenue() {
		String wordList[] = content_.split("at:");
		if(wordList.length <= 1){
			state_.setIsVenueChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListDetails[] = wordList[wordList.length-1].split("details:");
			if(wordListDetails.length <= 1){
				state_.setIsVenueChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				state_.setIsVenueChanged(true);
				return wordListDetails[0].trim();
			}
		}
	}

	@Override
	public Date getStartDate() {
		String wordList[] = content_.split("from:");
		if(wordList.length==1){
			state_.setIsStartDateChanged(false);
			return null;
		}
		String endDate = wordList[wordList.length-1].trim();
		String wordListEnd[] = endDate.split("to:");
		
		if(wordListEnd.length<=1){
			state_.setIsStartDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
		Date date = TimeParser.stringToDate(wordListEnd[0].trim());
		if(date != null){
			state_.setIsStartDateChanged(true);
			return date;
		}else{
			state_.setIsStartDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	@Override
	public Date getEndDate() {
		if(state_.getIsStartDateChanged()){
			String wordList[] = content_.split("to:");
			if(wordList.length==1){
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
			Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
			if(date != null){
				state_.setIsEndDateChanged(true);
				if(date.before(state_.getStartDate())){
					state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_ERROR);
					state_.setIsValid(false);
					state_.setIsEndDateChanged(false);
					state_.setIsStartDateChanged(false);
					return null;
				}
				return date;
			}else{
				state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
				state_.setIsValid(false);
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
		}
		String wordList[] = content_.split("on:");
		if(wordList.length==1){
			state_.setIsEndDateChanged(false);
			return null;
		}
		Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
		if(date != null){
			state_.setIsEndDateChanged(true);
			return date;
		}else{
			state_.setIsEndDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		if(state_.getIsStartDateChanged()){
			String wordList[] = content_.split("from:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsEndDateChanged()){
			String wordList[] = content_.split("on:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsVenueChanged()){
			String wordList[] = content_.split("at:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsDetailChanged()){
				String wordListDetail[] = wordList[0].split("details:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListDetail[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else if(state_.getIsDetailChanged()){
			String wordList[] = content_.split("details:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsVenueChanged()){
				String wordListVenue[] = wordList[0].split("at:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListVenue[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else{
			state_.setIsContentChanged(true);
			return content_;
		}
	}


	@Override
	public TaskType getTaskType() {
		if(state_.getIsEndDateChanged()){
			return TaskType.DEADLINE;
		}else{
			return TaskType.FLOATING;
		}
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
	
}
```
###### \src\parser\CommandChangeMode.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandChangeMode implements Command{
	private State state_;
	private String content_;
	
	public CommandChangeMode(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		ViewMode viewMode = determineViewMode();
		return viewMode;
	}
	
	/*
	 * Get the view mode based on content
	 * Pre-Cond: Valid view mode specified by the user
	 * Post-Cond: Returning the respective view mode
	 */
	private ViewMode determineViewMode() {
		if(content_.equalsIgnoreCase("FLOATING")){
			return ViewMode.FLOATING;
		} else if(content_.equalsIgnoreCase("DEADLINE")){
			return ViewMode.DEADLINE;
		} else if(content_.equalsIgnoreCase("ALL")){
			return ViewMode.ALL;
		} else if(content_.equalsIgnoreCase("SEARCH")){
			return ViewMode.SEARCH;
		} else if(content_.equalsIgnoreCase("CONFIG")){
			return ViewMode.CONFIG;
		} else if(content_.equalsIgnoreCase("FINISHED")){
			return ViewMode.FINISHED;
		} else {
			return ViewMode.UNDEFINED;
		}
	}
}
```
###### \src\parser\CommandClear.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandClear implements Command{
	private State state_;
	private String content_;
	
	public CommandClear(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \src\parser\CommandConfig.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.Font;
import common.State;
import common.TaskType;
import common.Theme;
import common.ViewMode;

public class CommandConfig implements Command{
	private State state_;
	private String content_;
	
	public CommandConfig(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		state_.setFont(getFont());
		state_.setTheme(getTheme());
		
	}

	private Theme getTheme() {
		if(content_.equalsIgnoreCase("autumn")){
			return Theme.AUTUMN;
		}else if(content_.equalsIgnoreCase("bokeh")){
			return Theme.BOKEH;
		}else if(content_.equalsIgnoreCase("branch")){
			return Theme.BRANCH;
		}else if(content_.equalsIgnoreCase("cat")){
			return Theme.CAT;
		}else if(content_.equalsIgnoreCase("japanese")){
			return Theme.JAPANESE;
		}else if(content_.equalsIgnoreCase("leather")){
			return Theme.LEATHER;
		}else if(content_.equalsIgnoreCase("paris")){
			return Theme.PARIS;
		}else if(content_.equalsIgnoreCase("raindrop")){
			return Theme.RAINDROP;
		}else if(content_.equalsIgnoreCase("warm")){
			return Theme.WARM;
		}else if(content_.equalsIgnoreCase("wheat")){
			return Theme.WHEAT;
		}else{
			return Theme.AUTUMN;
		}
	}
	private Font getFont() {
		if(content_.equalsIgnoreCase("consolas")){
			return Font.CONSOLAS;
		}else if(content_.equalsIgnoreCase("segoe")){
			return Font.SEGOE;
		}else{
			return Font.SEGOE;
		}
	}
	
	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(true);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandDelete.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandDelete implements Command{
	private State state_;
	private String content_;
	
	public CommandDelete(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	};
	
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandDetail.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandDetail implements Command{
	private State state_;
	private String content_;
	
	public CommandDetail(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandHelp.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandHelp implements Command{
	private State state_;
	private String content_;
	
	public CommandHelp(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandRedo.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandRedo implements Command{
	private State state_;
	private String content_;
	
	public CommandRedo(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \src\parser\CommandSearch.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandSearch implements Command{
	private State state_;
	private String content_;
	
	public CommandSearch(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		ArrayList<String> keywords = new ArrayList<String>();
		String inputKeyWords[] = content_.split(" ");
		if(inputKeyWords.length == 0){
			state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
		}
		for(int i = 0; i<inputKeyWords.length; i++){
			keywords.add(inputKeyWords[i]);
		}
		return keywords;
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.SEARCH;
	}

}
```
###### \src\parser\CommandTick.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandTick implements Command{
	private State state_;
	private String content_;
	
	public CommandTick(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandUndo.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandUndo implements Command{
	private State state_;
	private String content_;
	
	public CommandUndo(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandUntick.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandUntick implements Command{
	private State state_;
	private String content_;
	
	public CommandUntick(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	@Override
	public Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	@Override
	public int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	@Override
	public String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	@Override
	public TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \src\parser\CommandUpdate.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandUpdate implements Command{
	private State state_;
	private String content_;
	
	public CommandUpdate(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	@Override
	public String getDetail() {
		String content = getContentWithoutIndex();
		String wordList[] = content.split("details:");
		if(wordList.length <= 1){
			state_.setIsDetailChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListVenue[] = wordList[wordList.length-1].split("at:");
			if(wordListVenue.length <= 1){
				state_.setIsDetailChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				state_.setIsDetailChanged(true);
				return wordListVenue[0].trim();
			}
		}
	}

	@Override
	public String getVenue() {
		String content = getContentWithoutIndex();
		String wordList[] = content.split("at:");
		if(wordList.length <= 1){
			state_.setIsVenueChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			String wordListDetails[] = wordList[wordList.length-1].split("details:");
			if(wordListDetails.length <= 1){
				state_.setIsVenueChanged(true);
				return wordList[wordList.length-1].trim();
			}else{
				state_.setIsVenueChanged(true);
				return wordListDetails[0].trim();
			}
		}
	}

	@Override
	public Date getStartDate() {
		String wordList[] = content_.split("from:");
		if(wordList.length<=1){
			state_.setIsStartDateChanged(false);
			return null;
		}
		String endDate = wordList[wordList.length-1].trim();
		String wordListEnd[] = endDate.split("to:");
		
		if(wordListEnd.length<=1){
			state_.setIsStartDateChanged(false);
			state_.setIsValid(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			return null;
		}
		Date date = TimeParser.stringToDate(wordListEnd[0].trim());
		if(date != null){
			state_.setIsStartDateChanged(true);
			return date;
		}else{
			state_.setIsStartDateChanged(false);
			state_.setIsValid(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			return null;
		}
	}

	@Override
	public Date getEndDate() {
		if(state_.getIsStartDateChanged()){
			String wordList[] = content_.split("to:");
			if(wordList.length<=1){
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
			Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
			if(date != null){
				state_.setIsEndDateChanged(true);
				if(date.before(state_.getStartDate())){
					state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_ERROR);
					state_.setIsValid(false);
					state_.setIsEndDateChanged(false);
					state_.setIsStartDateChanged(false);
					return null;
				}
				return date;
			}else{
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
				state_.setIsValid(false);
				return null;
			}
		}
		String wordList[] = content_.split("on:");
		if(wordList.length<=1){
			state_.setIsEndDateChanged(false);
			return null;
		}
		Date date = TimeParser.stringToDate(wordList[wordList.length-1].trim());
		if(date != null){
			state_.setIsEndDateChanged(true);
			return date;
		}else{
			state_.setIsEndDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	@Override
	public int getPositionIndex() {
		String wordList[] = content_.split(" ");
		return Integer.parseInt(wordList[0]);
	}

	@Override
	public String getContent() {
		String content = getContentWithoutIndex().trim();
		if(state_.getIsStartDateChanged()){
			String wordList[] = content.split("from:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsEndDateChanged()){
			String wordList[] = content.split("on:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return wordList[0].trim();
		}else if(state_.getIsVenueChanged()){
			String wordList[] = content.split("at:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsDetailChanged()){
				String wordListDetail[] = wordList[0].split("details:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListDetail[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else if(state_.getIsDetailChanged()){
			String wordList[] = content.split("details:");
			if(wordList.length <= 1 || wordList[0].isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			if(state_.getIsVenueChanged()){
				String wordListVenue[] = wordList[0].split("at:");
				if(wordList.length <= 1 || wordList[0].isEmpty()){
					state_.setIsContentChanged(true);
					return wordList[0].trim();
				}else{
					state_.setIsContentChanged(true);
					return wordListVenue[0].trim();
				}
			}else{
				state_.setIsContentChanged(true);
				return wordList[0].trim();
			}
		}else{
			if(content.trim().isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
			}
			state_.setIsContentChanged(true);
			return content;
		}
	}

	private String getContentWithoutIndex() {
		String inputWords[] = content_.split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
	
	@Override
	public TaskType getTaskType() {
		if(state_.getIsEndDateChanged()){
			return TaskType.DEADLINE;
		}else{
			return TaskType.FLOATING;
		}
	}

	@Override
	public ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	@Override
	public ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \src\parser\Parser.java
``` java
package parser;

import java.lang.StringBuilder;

import common.*;

public class Parser {
	
	private State state_;
	private ParserErrorChecker errorChecker_;
	private CommandAdd add_;
	private CommandChangeMode changeMode_;
	private CommandClear clear_;
	private CommandDelete delete_;
	private CommandDetail detail_;
	private CommandExit exit_;
	private CommandRedo redo_;
	private CommandSearch search_;
	private CommandTick tick_;
	private CommandUndo undo_;
	private CommandUpdate update_;
	private CommandHelp help_;
	private CommandUntick untick_;
	private CommandConfig config_;
	
	
	/*
	 * Initializing parser
	 * Pre-Cond: None
	 * Post-Cond: A parser instance
	 */
 	public Parser(State state){
		state_ = state;
		errorChecker_ = new ParserErrorChecker(state);
		add_ = new CommandAdd(state);
		changeMode_ = new CommandChangeMode(state);
		clear_ = new CommandClear(state);
		delete_ = new CommandDelete(state);
		detail_ = new CommandDetail(state);
		exit_ = new CommandExit(state);
		redo_ = new CommandRedo(state);
		search_ = new CommandSearch(state);
		tick_ = new CommandTick(state);
		undo_ = new CommandUndo(state);
		update_ = new CommandUpdate(state);
		help_ = new CommandHelp(state);
		config_= new CommandConfig(state);
		untick_ = new CommandUntick(state);
		
	}
	
	/*
	 * Break down a string of input into smaller parts for logic to process
	 * Pre-Cond: Input of the user in the state
	 * Post-Cond: Updated State
	 */
	public boolean processInput(){
		errorChecker_.checkError();
		if(state_.getIsValid()){
			state_.setCommandType(getCommand());
			CommandType command = state_.getCommandType();
			switch(command){
				
				case ADD:
					add_.processInput();
					break;
				
				case CHANGEMODE:
					changeMode_.processInput();
					break;
					
				case CLEAR:
					clear_.processInput();
					break;
					
				case DELETE:
					delete_.processInput();
					break;
					
				case DETAIL:
					detail_.processInput();
					break;
					
				case EXIT:
					exit_.processInput();
					break;
					
				case REDO:
					redo_.processInput();
					break;
					
				case SEARCH:
					search_.processInput();
					break;
					
				case TICK:
					tick_.processInput();
					break;
					
				case UNDO:
					undo_.processInput();
					break;
					
				case UPDATE:
					update_.processInput();
					break;
					
				case HELP:
					help_.processInput();
					break;
					
				case UNTICK:
					untick_.processInput();
					break;
					
				case CONFIG:
					config_.processInput();
					break;
			}
			
		}
		return state_.getIsValid();
	}
	
	
	/*
	 * Get the command of an input
	 * Pre-Cond: Input of a user
	 * Post-Cond: CommandType
	 */
	public CommandType getCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		return determineCommandType(inputWords[0]);
	}

	
	/*
	 * Get the command type based on input
	 * Pre-Cond: String of command
	 * Post-Cond: CommandType of the given input
	 */
	public CommandType determineCommandType(String commandTypeString) {
		if (commandTypeString == null) {
			throw new Error("Command type string cannot be null!");
		}
		
		if (commandTypeString.equalsIgnoreCase("add")) {
			return CommandType.ADD;
		} else if (commandTypeString.equalsIgnoreCase("delete")) {
			return CommandType.DELETE;
		} else if (commandTypeString.equalsIgnoreCase("update")) {
			return CommandType.UPDATE;
		} else if (commandTypeString.equalsIgnoreCase("clear")) {
			return CommandType.CLEAR;
		} else if (commandTypeString.equalsIgnoreCase("tick")) {
			return CommandType.TICK;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return CommandType.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return CommandType.REDO;
		} else if (commandTypeString.equalsIgnoreCase("search")) {
			return CommandType.SEARCH;
		} else if (commandTypeString.equalsIgnoreCase("exit")) {
			return CommandType.EXIT;
		} else if (commandTypeString.equalsIgnoreCase("view")) {
			String inputWords[] = state_.getUserInput().split(" ");
			String argument = inputWords[1];
			if(argument.matches("\\d+")){
				return CommandType.DETAIL;
			}else{
				return CommandType.CHANGEMODE;
			}
		}
		return CommandType.ERROR;
	}
}
```
###### \src\parser\ParserErrorChecker.java
``` java
package parser;

import common.CommandType;
import common.Constant;
import common.State;

public class ParserErrorChecker {
	private State state_;
	
	public ParserErrorChecker(State state){
		state_ = state;
	}
	
	public void checkError(){
		state_.setDisplayMessage(getErrorMessage());
		state_.setIsValid(getIsValid());
	}
	
	/*
	 * Check whether parsed command is valid
	 * Pre-Cond: None
	 * Post-Cond: True if command input is valid. False otherwise.
	 */
	private boolean getIsValid() {
		return state_.getDisplayMessage().equals(Constant.VALUE_ERROR_NO_ERROR);
	}
	
	/*
	 * Get the error message for a given input. 
	 * Pre-Cond: None
	 * Post-Cond: Respective error message 
	 */
	private String getErrorMessage() {
		if(isInputEmpty()){
			return Constant.VALUE_ERROR_NO_INPUT;
		}
		if(isCommandInvalid()){
			return Constant.VALUE_ERROR_COMMAND_NOT_FOUND;
		}
		if(isArgumentInvalid()){
			return Constant.VALUE_ERROR_INVALID_ARGUMENT;
		}
		return Constant.VALUE_ERROR_NO_ERROR;
	}

	/*
	 * Check whether the input is an empty string
	 * Pre-Cond: None
	 * Post-Cond: true if it is empty. false otherwise
	 */	
	private boolean isInputEmpty() {
		return state_.getUserInput().length() == 0;
	}
	
	/*
	 * Check whether the input has a valid command (add, update, tick, delete, clear, exit, etc)
	 * Pre-Cond: None
	 * Post-Cond: True if it is valid. False otherwise
	 */
	private boolean isCommandInvalid() {
		if(!isInputEmpty()){
			CommandType commandType = getCommand();
			switch(commandType) {
				
				case ADD:
					return false;	
				
				case CLEAR:
					return false;
				
				case DELETE:
					return false;
				
				case TICK:
					return false;	
				
				case UPDATE:
					return false;
					
				case EXIT:
					return false;
					
				case UNDO:
					return false;
				
				case REDO:
					return false;
					
				case CHANGEMODE:
					return false;
					
				case SEARCH:
					return false;
				
				case DETAIL:
					return false;
					
				case HELP:
					return false;
					
				case CONFIG:
					return false;
					
				case UNTICK:
					return false;
					
				default: 
					return true;
			}
		}
		return false;
	}
	
	/*
	 * Check whether the input has the correct and valid argument for the given command
	 * Pre-Cond: None
	 * Post-Cond: True if it's invalid. False otherwise
	 */
	private boolean isArgumentInvalid() {
		if(!isCommandInvalid()){
			CommandType commandType = getCommand();
			String content = getContentWithoutCommand();
			try{
				switch(commandType){
				
					case ADD:
						if(content.length() == 0){
							return true;
						}
						return false;
					
					case CLEAR:
						if(content.isEmpty()){
							return false;
						}
						return true;
				
					case DELETE:
						if(content.matches("\\d+")){
							return false;
						}
						return true;
				
					case EXIT:
						if(content.length() != 0){
							return true;
						}
						return false;
					
					case UNDO:
						if(content.length() != 0){
							return true;
						}
						return false;
					
					case REDO:
						if(content.length() != 0){
							return true;
						}
						return false;
						
					case SEARCH:
						if(content.length() == 0){
							return true;
						}
						return false;
						
					case TICK:
						if(content.matches("\\d+")){
							return false;
						}
						return true;
					
					case UPDATE:
						String inputWords[] = content.split(" ");
						if(!inputWords[0].matches("\\d+") || content.length() == 0 || inputWords.length ==1){
							return true;
						}
						return false;
					
					case DETAIL:
						if(content.matches("\\d+")){
							return false;
						}
						return true;
					
					case CHANGEMODE:
						if(content.equalsIgnoreCase("FLOATING") || content.equalsIgnoreCase("DEADLINE") 
								|| content.equalsIgnoreCase("ALL") || content.equalsIgnoreCase("SEARCH") 
								|| content.equalsIgnoreCase("FINISHED") || content.equalsIgnoreCase("CONFIG")){
							return false;
						}
						return true;
					
					case HELP:
						if(content.length() != 0){
							return true;
						}
						return false;
					
					case CONFIG:
						if(content.equalsIgnoreCase("CONSOLAS") || content.equalsIgnoreCase("SEGOE")
							|| content.equalsIgnoreCase("AUTUMN") || content.equalsIgnoreCase("BOKEH")
							|| content.equalsIgnoreCase("BRANCH") || content.equalsIgnoreCase("CAT")
							|| content.equalsIgnoreCase("JAPANESE") || content.equalsIgnoreCase("LEATHER")
							|| content.equalsIgnoreCase("PARIS") || content.equalsIgnoreCase("RAINDROP")
							|| content.equalsIgnoreCase("WARM") || content.equalsIgnoreCase("WHEAT")){
							return false;
						}else{
							return true;
						}
					case UNTICK:
						if(content.matches("\\d+")){
							return false;
						}
						return true;
						
					default: 
						return false;
				}
			}
			catch(IllegalArgumentException e){
				return true;
			}
		}else{
			return false;
		}
	}


	/*
	 * Get the content of user input without the command word
	 */
	private String getContentWithoutCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
	/*
	 * Get the command of an input
	 * Pre-Cond: Input of a user
	 * Post-Cond: CommandType
	 */
	private CommandType getCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		return determineCommandType(inputWords[0]);
	}

	
	/*
	 * Get the command type based on input
	 * Pre-Cond: String of command
	 * Post-Cond: CommandType of the given input
	 */
	private CommandType determineCommandType(String commandTypeString) {
		if (commandTypeString == null) {
			throw new Error("Command type string cannot be null!");
		}
		
		if (commandTypeString.equalsIgnoreCase("add")) {
			return CommandType.ADD;
		} else if (commandTypeString.equalsIgnoreCase("delete")) {
			return CommandType.DELETE;
		} else if (commandTypeString.equalsIgnoreCase("update")) {
			return CommandType.UPDATE;
		} else if (commandTypeString.equalsIgnoreCase("clear")) {
			return CommandType.CLEAR;
		} else if (commandTypeString.equalsIgnoreCase("tick")) {
			return CommandType.TICK;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return CommandType.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return CommandType.REDO;
		} else if (commandTypeString.equalsIgnoreCase("search")) {
			return CommandType.SEARCH;
		} else if (commandTypeString.equalsIgnoreCase("exit")) {
			return CommandType.EXIT;
		} else if (commandTypeString.equalsIgnoreCase("view")) {
			String inputWords[] = state_.getUserInput().split(" ");
			String argument = inputWords[1];
			if(argument.matches("\\d+")){
				return CommandType.DETAIL;
			}else{
				return CommandType.CHANGEMODE;
			}
		}
		return CommandType.ERROR;
	}
}
```
###### \src\parser\TimeParser.java
``` java
package parser;

import com.joestelmach.natty.*;

import java.util.Calendar;
import java.util.Date;
import java.util.List;


public class TimeParser{
 private static com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
 
 public static Date stringToDate(String str){
	 try {
		 Date current = getCurrentDate();
		 List<DateGroup> groups = dateParser.parse(str);
		 Date date = groups.get(0).getDates().get(0);
		 Calendar cal = Calendar.getInstance();
		 Calendar calCurrent = Calendar.getInstance();
		 cal.setTime(date);
		 calCurrent.setTime(current);
		 if(cal.get(Calendar.HOUR_OF_DAY) == calCurrent.get(Calendar.HOUR_OF_DAY) && cal.get(Calendar.MINUTE) == calCurrent.get(Calendar.MINUTE)){
			 cal.set(Calendar.HOUR_OF_DAY, 23);
			 cal.set(Calendar.MINUTE, 59);
			 cal.set(Calendar.SECOND, 59);
		 }
		 
		 
		 return cal.getTime();
	 } catch (Exception e){
		 return null;
	 }
 }
 
 public static Date getCurrentDate(){
	 return Calendar.getInstance().getTime();
 }
}


```
