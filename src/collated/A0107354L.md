# A0107354L
###### \common\State.java
``` java

package common;

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;

public class State {
	private boolean isValid_, isStartDateChanged_, isEndDateChanged_, isContentChanged_, isVenueChanged_, isDetailChanged_;
	private String content_, detail_, userInput_, venue_, displayMessage_;
	private Font font_, newFont_;
	private Theme theme_, newTheme_;
	private TaskType taskType_;
	private CommandType commandType_;
	private ViewMode viewMode_;
	private ViewMode newViewMode_;	
	private int positionIndex_;
	private Date startDate_, endDate_;
	private ArrayList<Task> floatingTasks_,deadlineTasks_, allTasks_, searchResultTasks_, finishedTasks_, todaysTasks_;
	private ArrayList<String> searchKey_;
	private String currentDirectory_;
	private String newDirectory_;
	private int errorFrequency;
	
	public State(){
		isValid_ = Constant.VALUE_DEFAULT_BOOLEAN_TRUE;
		isStartDateChanged_ = Constant.VALUE_DEFAULT_BOOLEAN_FALSE;
		isEndDateChanged_ = Constant.VALUE_DEFAULT_BOOLEAN_FALSE; 
		isContentChanged_ = Constant.VALUE_DEFAULT_BOOLEAN_FALSE; 
		isVenueChanged_ = Constant.VALUE_DEFAULT_BOOLEAN_FALSE; 
		isDetailChanged_ = Constant.VALUE_DEFAULT_BOOLEAN_FALSE;
		commandType_ = CommandType.UNDEFINED;
		viewMode_ = Constant.VALUE_DEFAULT_VIEW_MODE;
		newViewMode_ = null;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
		detail_ = Constant.VALUE_DEFAULT_EMPTY;
		userInput_ = Constant.VALUE_DEFAULT_EMPTY;
		venue_ = Constant.VALUE_DEFAULT_EMPTY;
		displayMessage_ = Constant.VALUE_DEFAULT_EMPTY;
		taskType_ = TaskType.UNDEFINED;
		positionIndex_ = Constant.VALUE_DEFAULT_POSITION_INDEX;
		startDate_ = null;
		endDate_ = null;
		floatingTasks_ = new ArrayList<Task>();
		deadlineTasks_ = new ArrayList<Task>();
		allTasks_ = new ArrayList<Task>();
		searchResultTasks_ = new ArrayList<Task>();
		finishedTasks_ = new ArrayList<Task>();
		todaysTasks_ = new ArrayList<Task>();
		searchKey_ = new ArrayList<String>();
		theme_ = Theme.AUTUMN;
		newTheme_ = Theme.AUTUMN;
		font_ = Font.SEGOE;
		newFont_ = Font.SEGOE;
		errorFrequency = 0;
	}
	
	/*
	 * List of accessors and mutators for private attributes
	 */
	
	public void setCurrentDirectory(String directory) {
		this.currentDirectory_ = directory;
	}
	
	public String getCurrentDirectory() {
		return this.currentDirectory_ ;
	}
	
	public void setNewDirectory(String directory) {
		this.newDirectory_ = directory;
	}
	
	public String getNewDirectory() {
		return this.newDirectory_;
	}
	
	public void setIsValid(boolean bool){
		isValid_ = bool;
	}
	
	public boolean getIsValid(){
		return isValid_;
	}

	public void setIsStartDateChanged(boolean bool){
		isStartDateChanged_ = bool;
	}
	
	public boolean getIsStartDateChanged(){
		return isStartDateChanged_;
	}
	
	public void setIsEndDateChanged(boolean bool){
		isEndDateChanged_ = bool;
	}
	
	public boolean getIsEndDateChanged(){
		return isEndDateChanged_;
	}
	
	public void setIsContentChanged(boolean bool){
		isContentChanged_ = bool;
	}
	
	public boolean getIsContentChanged(){
		return isContentChanged_;
	}
	
	public void setIsVenueChanged(boolean bool){
		isVenueChanged_ = bool;
	}
	
	public boolean getIsVenueChanged(){
		return isVenueChanged_;
	}
	
	public void setIsDetailChanged(boolean bool){
		isDetailChanged_ = bool;
	}
	
	public boolean getIsDetailChanged(){
		return isDetailChanged_;
	}

	public void setCommandType(CommandType command){
		commandType_ = command;
	}

	public CommandType getCommandType(){
		return commandType_;
	}
	
	public void setTaskType(TaskType type){
		taskType_ = type;
	}
	
	public TaskType getTaskType(){
		return taskType_;
	}
	
	public void setViewMode(ViewMode vm){
		viewMode_ = vm;
	}
	
	public ViewMode getViewMode(){
		return viewMode_;
	}

	public void setNewViewMode(ViewMode vm){
		newViewMode_ = vm;
	}
	
	public ViewMode getNewViewMode(){
		return newViewMode_;
	}
	
	public void setContent(String content){
		content_ = content;
	}

	public String getContent(){
		return content_;
	}
	
	public void setVenue(String venue){
		venue_ = venue;
	}	

	public String getVenue(){
		return venue_;
	}
	
	public void setDetail(String detail){
		detail_ = detail;
	}

	public String getDetail(){
		return detail_;
	}
	
	public void setDisplayMessage(String errorMessage){
		if (errorFrequency >= Constant.THRESHOLD_ERROR_FREQUENCY){
			resetErrorFrequency();
			displayMessage_ = Constant.ERROR_RECOMMENDATION;
		} else {
			displayMessage_ = errorMessage;
		}
	}

	public String getDisplayMessage(){
		return displayMessage_;
	}
	
	public void setSearchKey(ArrayList<String> searchKey){
		searchKey_ = searchKey;
	}

	public ArrayList<String> getSearchKey(){
		return searchKey_;
	}
	
	public void setUserInput(String userInput){
		userInput_ = userInput;
	}	
	
	public String getUserInput(){
		return userInput_;
	}
	
	public void setPositionIndex(int position){
		this.positionIndex_ = position;
	}

	public int getPositionIndex(){
		return positionIndex_;
	}

	public void setStartDate(Date startDate){
		startDate_ = startDate;
	}
	
	public Date getStartDate(){
		return startDate_;
	}

	public void setEndDate(Date endDate){
		endDate_ = endDate;
	}
	
	public Date getEndDate(){
		return endDate_;
	}
	
//	private ArrayList<Task> floatingTasks_,normalTasks_, allTask_, searchResultTasks_, FinishedTasks_;

	public void setFloatingTasks (ArrayList<Task> floatingTasks){
		floatingTasks_ = floatingTasks;
	}
	
	public ArrayList<Task> getFloatingTasks (){
		return floatingTasks_;
	}
	
	public void setDeadlineTasks (ArrayList<Task> deadlineTasks){
		deadlineTasks_ = deadlineTasks;
	}

	public ArrayList<Task> getDeadlineTasks (){
		return deadlineTasks_;
	}
	
	public void setAllTasks (ArrayList<Task> allTasks){
		allTasks_ = allTasks;
	}

	public ArrayList<Task> getAllTasks (){
		return allTasks_;
	}
	
	public void setSearchResultTasks (ArrayList<Task> searchResultTasks){
		searchResultTasks_ = searchResultTasks;
	}
	
	public ArrayList<Task> getSearchResultTasks (){
		return searchResultTasks_;
	}
	
	public void setFinishedTasks (ArrayList<Task> finishedTasks){
		finishedTasks_ = finishedTasks;
	}

	public ArrayList<Task> getFinishedTasks(){
		return finishedTasks_;
	}

	public ArrayList<Task> getTodaysTasks(){
		return todaysTasks_;
	}
	
	
	public boolean recoverFrom(State oldState){
		isValid_ = oldState.getIsValid();
		isStartDateChanged_ = oldState.getIsStartDateChanged();
		isEndDateChanged_ = oldState.getIsEndDateChanged();
		isContentChanged_ = oldState.getIsContentChanged();
		isVenueChanged_ = oldState.getIsVenueChanged();
		isDetailChanged_ = oldState.getIsDetailChanged();
		content_ = oldState.getContent();
		detail_ = oldState.getDetail();
		userInput_ = oldState.getUserInput();
		venue_ = oldState.getVenue();
		displayMessage_ = oldState.getDisplayMessage();
		taskType_ = oldState.getTaskType();
		commandType_ = oldState.getCommandType();
		viewMode_ = oldState.getViewMode();
		newViewMode_ = oldState.getNewViewMode();	
		positionIndex_ = oldState.getPositionIndex();
		startDate_ = oldState.getStartDate();
		endDate_ = oldState.getEndDate();

		ArrayList<Task> floatingTasks = oldState.getFloatingTasks();
		ArrayList<Task> deadlineTasks = oldState.getDeadlineTasks();
		ArrayList<Task> allTasks = oldState.getAllTasks();
		ArrayList<Task> searchResultTasks = oldState.getSearchResultTasks();
		ArrayList<Task> finishedTasks = oldState.getFinishedTasks();
		ArrayList<String> searchKey = oldState.getSearchKey();	
		
		floatingTasks_ = new ArrayList<Task>();
		for(int i = 0; i < floatingTasks.size(); i++){
			floatingTasks_.add(floatingTasks.get(i));
		}
		
		deadlineTasks_ = new ArrayList<Task>();
		for(int i = 0; i < deadlineTasks.size(); i++){
			deadlineTasks_.add(deadlineTasks.get(i));
		}
		
		allTasks_ = new ArrayList<Task>();
		for(int i = 0; i < allTasks.size(); i++){
			allTasks_.add(allTasks.get(i));
		}
		
		searchResultTasks_ = new ArrayList<Task>();
		for(int i = 0; i < searchResultTasks.size(); i++){
			searchResultTasks_.add(searchResultTasks.get(i));
		}
		
		finishedTasks_ = new ArrayList<Task>();
		for(int i = 0; i < finishedTasks.size(); i++){
			finishedTasks_.add(finishedTasks.get(i));
		}
		
		searchKey_ = new ArrayList<String>();
		for(int i = 0; i < searchKey.size(); i++){
			searchKey_.add(searchKey.get(i));
		}

		return true;
	}

	public State deepCopy(){
		State newState = new State();
		boolean isValid = isValid_; 
		boolean isStartDateChanged = isStartDateChanged_, isEndDateChanged = isEndDateChanged_;
		boolean isContentChanged= isContentChanged_, isVenueChanged = isVenueChanged_, isDetailChanged =isDetailChanged_;
		String content, detail, userInput, venue, displayMessage;
		Date startDate;
		Date endDate;
		content = new String(content_);
		detail = new String(detail_);
		userInput = new String(userInput_);
		venue = new String(venue_);
		displayMessage = new String(displayMessage_);
		
		TaskType taskType = taskType_;
		CommandType commandType = commandType_;
		ViewMode viewMode = viewMode_;
		int positionIndex = positionIndex_;
		
		
		if (startDate_!=null) {
			startDate = new Date(startDate_.getTime());
		} else {
			startDate = null;
		}
		if (endDate_!=null) {
			endDate = new Date(endDate_.getTime());
		} else {
			endDate = null;
		}
		
		
		ArrayList<Task> floatingTasks = new ArrayList<Task>();
		for(int i = 0; i < floatingTasks_.size(); i++){
			floatingTasks.add(floatingTasks_.get(i));
		}
		
		ArrayList<Task> deadlineTasks = new ArrayList<Task>();
		for(int i = 0; i < deadlineTasks_.size(); i++){
			deadlineTasks.add(deadlineTasks_.get(i));
		}
		
		ArrayList<Task> allTasks = new ArrayList<Task>();
		for(int i = 0; i < allTasks_.size(); i++){
			allTasks.add(allTasks_.get(i));
		}
		
		ArrayList<Task> searchResultTasks = new ArrayList<Task>();
		for(int i = 0; i < searchResultTasks_.size(); i++){
			searchResultTasks.add(searchResultTasks_.get(i));
		}
		
		ArrayList<Task> finishedTasks = new ArrayList<Task>();
		for(int i = 0; i < finishedTasks_.size(); i++){
			finishedTasks.add(finishedTasks_.get(i));
		}
		
		ArrayList<Task> startTasks = new ArrayList<Task>();
		for(int i = 0; i < startTasks.size(); i++){
			startTasks.add(startTasks.get(i));
		}
		
		ArrayList<String> searchKey = new ArrayList<String>();
		for(int i = 0; i < searchKey_.size(); i++){
			searchKey.add(searchKey_.get(i));
		}
		
		newState.setIsValid(isValid);
		newState.setIsStartDateChanged(isStartDateChanged);
		newState.setIsEndDateChanged(isEndDateChanged);
		newState.setIsContentChanged(isContentChanged);
		newState.setIsVenueChanged(isVenueChanged);
		newState.setIsDetailChanged(isDetailChanged);
		
		newState.setContent(content);
		newState.setDetail(detail);
		newState.setUserInput(userInput);
		newState.setVenue(venue);
		newState.setDisplayMessage(displayMessage);
		newState.setSearchKey(searchKey);	
		
		newState.setTaskType(taskType);
		newState.setCommandType(commandType);
		newState.setViewMode(viewMode);
		newState.setPositionIndex(positionIndex);
		newState.setStartDate(startDate);
		newState.setEndDate(endDate);
		
		newState.setFloatingTasks(floatingTasks);
		newState.setDeadlineTasks(deadlineTasks);
		newState.setAllTasks(allTasks);
		newState.setFinishedTasks(finishedTasks);
		newState.setSearchResultTasks(searchResultTasks);
		
		return newState;
	}
	
```
###### \common\Task.java
``` java

package common;
import java.util.Calendar;
import java.util.Date;

public class Task {
	private boolean isImportant, isDetailDisplayed;
	private Date startDate, endDate, creationDate;
	private String content, venue, detail;
	private TaskType taskType;

	private final String TO_STRING = "Task [ content: %s | venue: %s | detail: %s | type: %s"
										+ "isImportant: %b | startDate: %s | endDate: %s | creationDate: %s]";

	private final String DISPLAYED_DETAIL = "%1$s\n\nDetail: %2$s";
	private final String DISPLAYED_VENUE = "%1$s\n\nVenue: %2$s";
	private final String DISPLAYED_VENUE_DETAIL = "%1$s\n\nVenue: %2$s\nDetail: %3$s";
	
	public Task(State state) {
		
		if(state.getIsContentChanged()){
			this.content = state.getContent();
		} else {
			this.content = Constant.VALUE_DEFAULT_EMPTY;
		}

		if(state.getIsVenueChanged()){
			this.venue = state.getVenue();
		} else {
			this.venue = Constant.VALUE_DEFAULT_EMPTY;
		}
		
		if(state.getIsDetailChanged()){
			this.detail = state.getDetail();
		} else {
			this.detail = Constant.VALUE_DEFAULT_EMPTY;
		}
		
		this.isImportant = Constant.VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_IMPORTANT;
		this.isDetailDisplayed = Constant.VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_DETAIL_DISPLAYED;
				

		if(state.getIsStartDateChanged()){
			this.startDate = state.getStartDate();
		} else {
			this.startDate = null;
		}
			
		if(state.getIsEndDateChanged()){
			this.endDate = state.getEndDate();
			this.taskType = TaskType.DEADLINE;
		} else {
			this.endDate = null;
			this.taskType = TaskType.FLOATING;
		}
		
		this.creationDate = TimeParser.getCurrentDate();
	
	}


	public boolean getIsImportant(){
		return isImportant;
	}
	
	public void setIsImportant(boolean input){
		isImportant = input;
	}
	
	public boolean getIsDetailDisplayed(){
		return isDetailDisplayed;
	}
	
	public void setIsDetailDisplayed(boolean input){
		isDetailDisplayed = input;
	}

	public Date getStartDate(){
		return startDate;
	}
	
	public void setStartDate(Date dt){
		startDate = dt;
	}
	
	public Date getEndDate(){
		return endDate;
	}
	
	public void setEndDate(Date dt){
		endDate = dt;
	}	
	
	public Date getCreationDate(){
		return creationDate;
	}
	//no mutator for creation date
	
	public TaskType getTaskType(){
		return taskType;
	}
	
	public void setTaskType(TaskType type){
		taskType = type;
	}
	
	public String getContent(){
		return content;
	}
	
	public void setContent(String str){
		content = str;
	}
	
	public String getVenue(){
		return venue;
	}
	
	public void setVenue(String str){
		venue = str;
	}
	
	public String getDetail(){
		return detail;
	}
	
	public void setDetail(String str){
		detail = str;
	}

	public String concatString(){
		String result = "";
		if(startDate != null){
			result += startDate.toString();
		}
		if(endDate != null){
			result += endDate.toString();
		}
		result += content;
		result += venue;
		result += detail;
		
		return result.toLowerCase();
	}

	@Override
	public String toString(){
		String result;
		if ((startDate != null) && (endDate != null)) {
			result = String.format(TO_STRING, content,venue,detail,taskType,isImportant,
					 startDate.toString(), endDate.toString(), creationDate.toString());
		} else {
			result = String.format(TO_STRING, content,venue,detail,taskType,isImportant,
					 null, null, creationDate.toString());
		}
		
		
		return result;
	}
	
```
###### \common\TaskComparators.java
``` java
package common;

import java.util.Comparator;

public class TaskComparators {

	public static Comparator<Task> compareByEndDate = new Comparator<Task>(){
		public int compare(Task a, Task b){
			return  a.getEndDate().compareTo(b.getEndDate()); 
		}
	};

	public static Comparator<Task> compareByCreationDate = new Comparator<Task>(){
		public int compare(Task a, Task b){
			return  b.getCreationDate().compareTo(a.getCreationDate()); 
		}
	};
}
```
###### \logic\AddTask.java
``` java
package logic;

import java.util.ArrayList;
import java.util.Collections;

import common.State;
import common.Task;
import common.TaskComparators;
import common.TaskType;
import common.ViewMode;

public class AddTask implements Operation {
	
	//============================
	//       Attributes
	//============================
	private State state;
	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public AddTask(State state) {
		this.state = state;
	}

	/**
	 * Perform addition of new task
	 * If the taskType is undefined, return false.
	 *
	 * @return     boolean to indicate whether the addition is successful
	 */
	@Override
	public boolean process() {
		collapseAllTasks();
		Task newTask = new Task(state);
		TaskType taskType = newTask.getTaskType();
		
		switch (taskType) { 
			case FLOATING:
				addFloatingTask(newTask);
				return true;
			case DEADLINE:
				addDeadlineTask(newTask);
				return true;
			case UNDEFINED:
				return false;
			default:
				return true;
		}
	}

	/**
	 * add a deadline task
	 * @param newTask
	 */
	private void addDeadlineTask(Task newTask) {
		addToDeadlineList(newTask);
		addToAllList(newTask);
		setCurrentModeTo(ViewMode.DEADLINE);
		updatePositionIndex(newTask, TaskType.DEADLINE);
	}

	/**
	 * add a floating task
	 * @param newTask
	 */
	private void addFloatingTask(Task newTask) {
		addToFloatingList(newTask);
		addToAllList(newTask);
		setCurrentModeTo(ViewMode.FLOATING);		
		updatePositionIndex(newTask, TaskType.FLOATING);
	}


	/**
	 * add new task to deadline task list in state
	 * @param newTask
	 */
	private void addToDeadlineList(Task newTask) {
		ArrayList<Task> taskList = state.getDeadlineTasks();
		taskList.add(newTask);	
		Collections.sort(taskList, TaskComparators.compareByEndDate);
	}

	/**
	 * add new task to floating task list in state
	 * @param newTask
	 */
	private void addToFloatingList(Task newTask) {
		ArrayList<Task> taskList = state.getFloatingTasks();
		taskList.add(newTask);
		Collections.sort(taskList, TaskComparators.compareByCreationDate);
	}

	
	/**
	 * add new task to all task list in state
	 * @param newTask
	 */
	private void addToAllList(Task newTask) {
		ArrayList<Task> allTasks = state.getAllTasks();
		allTasks.add(newTask);
		Collections.sort(allTasks, TaskComparators.compareByCreationDate);
	}
	
	/**
	 * update the positionIndex in the state to the newly added task
	 * @param newTask newly added task
	 * @param taskType type of newly added task
	 * only newTask of type DEADLINE or FLOATING are supposed to invoke this method
	 */
	private void updatePositionIndex(Task newTask, TaskType taskType) {
		if(taskType == TaskType.DEADLINE){
			int indexOfNewTask = state.getDeadlineTasks().indexOf(newTask);
			state.setPositionIndex(indexOfNewTask);
		}
		
		if(taskType == TaskType.FLOATING){
			int indexOfNewTask = state.getFloatingTasks().indexOf(newTask);
			state.setPositionIndex(indexOfNewTask);
		}
	}
	

	/**
	 * switch the view mode to viewMode
	 * @param viewMode new view mode to be displayed
	 */
	private void setCurrentModeTo(ViewMode viewMode) {
		state.setViewMode(viewMode);
	}

	/**
	 * change the isDetailDisplayed attribute of every task to false 
	 * to collapse all tasks
	 */
	private void collapseAllTasks() {
		LogicUtils logicUtils = new LogicUtils(state);
		logicUtils.collapseAllTasks();
	}
}
```
###### \logic\ChangeViewMode.java
``` java
package logic;

import common.Constant;
import common.State;
import common.ViewMode;

public class ChangeViewMode implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public ChangeViewMode(State state) {
		this.state = state;
	}
	
	/**
	 * Perform change of viewMode
	 *
	 * @return     boolean to indicate whether the addition is successful
	 * collapse all tasks when changing view mode for better visual appearance
	 */
	@Override
	public boolean process() {
		ViewMode newViewMode = state.getNewViewMode();
		
		//View Search mode is meaningless
		if(newViewMode == ViewMode.SEARCH){
			state.setDisplayMessage(Constant.MESSAGE_CANNOT_VIEW_SEARCH);
			return false;
		}
		
		state.setViewMode(newViewMode);

		//Collapse allArrayList<Task> when switching view mode
		collapseAllTasks();
		
		return true;
	}

	/**
	 * change the isDetailDisplayed attribute of every task to false 
	 * to collapse all tasks
	 */
	private void collapseAllTasks() {
		LogicUtils logicUtils = new LogicUtils(state);
		logicUtils.collapseAllTasks();
	}

}
```
###### \logic\ClearTask.java
``` java
package logic;

import java.util.ArrayList;

import common.Constant;
import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;

public class ClearTask implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public ClearTask(State state) {
		this.state = state;
	}
	
	
	/**
	 * Perform clearance of all tasks
	 * If clearing under invalid mode(UNDEFINED, CONFIG, HELP)
	 *
	 * @return  boolean to indicate whether the addition is successful
	 */
	@Override
	public boolean process() {
		try {
			ViewMode viewMode = state.getViewMode();
			
			switch (viewMode) { 
				case FLOATING:
					clearUnderFloatingMode();
					return true;
				case DEADLINE:
					clearUnderDeadlineMode();
					return true;
				case ALL:
					clearUnderAllMode();
					return true;
				case SEARCH:
					clearUnderSearchMode();
					return true;
				case FINISHED:
					clearUnderFinishedMode();
					return true;
				case START:
					clearUnderStartMode();
					return true;
				case UNDEFINED:
					clearUnderInvalidMode();
					return false;
				case CONFIG:
					clearUnderInvalidMode();
					return false;
				case HELP:
					clearUnderInvalidMode();
					return false;
				default:
					return false;
			}		
					
		} catch (Exception e) {
			//logging
			state.setDisplayMessage(Constant.MESSAGE_DUMMY);
			return false;
		}
	}
	
	
	/**
	 * clear tasks under invalid mode
	 * set error message 
	 */
	private void clearUnderInvalidMode() {
		state.setDisplayMessage(Constant.MESSAGE_CLEAR_IN_WRONG_MODE);
	}
	

	/**
	 * clear tasks under all mode
	 * clear floating task list, deadline task list and all task list
	 */
	private void clearUnderAllMode() {
		clearDeadlineTasks();
		clearFloatingTasks();
		clearAllTasks();
	}

	/**
	 * clear tasks under deadline mode
	 * clear both deadline task list and deadline task in all task list
	 */
	private void clearUnderDeadlineMode() {
		clearDeadlineTasks();
		pruneAllTasks(TaskType.DEADLINE);
	}

	/**
	 * clear tasks under floating mode
	 * clear both floating task list and floating task in all task list
	 */
	private void clearUnderFloatingMode() {
		clearFloatingTasks();
		pruneAllTasks(TaskType.FLOATING);
	}
	
	/**
	 * clear all deadline tasks due before today midnight 
	 * from all task list, deadline task list and floating task list
	 * 
	 */
	private void clearUnderStartMode() {
		ArrayList<Task> todaysTasks = state.getTodaysTasks();
		for(int i = 0; i < todaysTasks.size(); i++){
			Task task = todaysTasks.get(i);
			deleteTask(task);
		}
		todaysTasks.clear();
	}
	
	
	/**
	 * clear all finished tasks from finished task list
	 * 
	 */
	private void clearUnderFinishedMode() {
		ArrayList<Task> finishedTask = state.getFinishedTasks();
		finishedTask.clear();
	}
	
	
	/**
	 * clear all searched tasks displayed in search mode
	 * from all task list, deadline task list and floating task list
	 * 
	 */
	private void clearUnderSearchMode() {
		ArrayList<Task> searchedTaskList = state.getSearchResultTasks();
		for(int i = 0; i < searchedTaskList.size(); i++){
			Task task = searchedTaskList.get(i);
			deleteTask(task);
		}
		searchedTaskList.clear();
	}
	


	/**
	 * clear all tasks list
	 * 
	 */
	private void clearAllTasks() {
		ArrayList<Task> allTaskList = state.getAllTasks();
		allTaskList.clear();
	}

	/**
	 * clear deadline tasks list
	 * 
	 */
	private void clearDeadlineTasks() {
		ArrayList<Task> taskList = state.getDeadlineTasks();
		taskList.clear();
	}

	/**
	 * clear floating tasks list
	 * 
	 */
	private void clearFloatingTasks() {
		ArrayList<Task> taskList = state.getFloatingTasks();
		taskList.clear();
	}

	/**
	 * remove tasks from all tasks list that has a certain task type
	 * @param taskType  task type of tasks to be pruned
	 * 
	 */
	private void pruneAllTasks(TaskType taskType) {

		ArrayList<Task> prunedAllTaskList = new ArrayList<Task>();
		ArrayList<Task> allTaskList = state.getAllTasks();
		for(int i = 0; i < allTaskList.size(); i++){
			Task another = allTaskList.get(i);
			if(another.getTaskType() != taskType){
				prunedAllTaskList.add(another);
			}
		}
		state.setAllTasks(prunedAllTaskList);
	}
	
	/**
	 * remove a certain task from all task list, deadline task list and floating task list
	 * if applicable
	 * @param task  task to be deleted
	 * 
	 */
	private void deleteTask(Task toBeDeleted) {
		ArrayList<Task> allTasks = state.getAllTasks();
		allTasks.remove(toBeDeleted);
		
		TaskType taskType = toBeDeleted.getTaskType();
		
		if(taskType == TaskType.FLOATING){
			ArrayList<Task> floatingTasks = state.getFloatingTasks();
			floatingTasks.remove(toBeDeleted);
		}
		
		if(taskType == TaskType.DEADLINE){
			ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
			deadlineTasks.remove(toBeDeleted);
		}
	}

}
```
###### \logic\Config.java
``` java
package logic;

import common.Font;
import common.State;
import common.Theme;
import storage.Storage;
import common.ViewMode;

public class Config implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;
	private Storage storage;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public Config(State state, Storage storage) {
		this.state = state;
		this.storage = storage;
	}

	/**
	 * Perform change of font, theme and storage path
	 *
	 * @return  boolean to indication whether the addition is successful
	 */
	@Override
	public boolean process() {
		
		Font newFont = state.getNewFont();
		Theme newTheme = state.getNewTheme();
		String newDir = state.getNewDirectory();
		

		ViewMode newViewMode = state.getNewViewMode();
		state.setViewMode(newViewMode);
		
		if(newFont != null){
			state.setFont(newFont);
		}
		
		if(newTheme != null){
			state.setTheme(newTheme);
		}
		
		if(newDir != null){
			state.setNewDirectory(newDir);
			
		}
		
		return true;
	}

}
```
###### \logic\DeleteTask.java
``` java
package logic;

import java.util.ArrayList;

import common.Constant;
import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;

public class DeleteTask implements Operation {

	//============================
	//       Attributes
	//============================
	private State state;


	//====================================
	//       Constructor and Initiliser
	//====================================

	public DeleteTask(State state) {
		this.state = state;
	}


	/**
	 * Perform deletion of new task
	 * If the index are out of bound or delete under CONFIG, HELP or UNDEFINED mode
	 * return false
	 *
	 * @return     boolean to indicate whether the deletion is successful
	 */
	@Override
	public boolean process() {
		try {
			// change position index from 1 base(user input) to zero base
			int positionIndexLocal = getAndValidatePositionIndex();

			ViewMode viewMode = state.getViewMode();
			
			switch (viewMode) { 
				case FLOATING:
					deletedUnderFloatingMode(positionIndexLocal);
					return true;
				case DEADLINE:
					deleteUnderDeadlineMode(positionIndexLocal);
					return true;				
				case ALL:
					deleteUnderAllMode(positionIndexLocal);
					return true;				
				case SEARCH:
					deleteUnderSearchMode(positionIndexLocal);
					return true;					
				case FINISHED:
					deleteUnderFinishedMode(positionIndexLocal);
					return true;
				case START:
					deleteUnderStartMode(positionIndexLocal);
					return true;
				case UNDEFINED:
					deleteUnderInvalidMode();
					return false;
				case CONFIG:
					deleteUnderInvalidMode();
					return false;
				case HELP:
					deleteUnderInvalidMode();
					return false;
				default:
					return false;
			}	
			
		} catch (IndexOutOfBoundsException e) {
			//logging
			deleteWithInvalidPositionIndex();
			return false;
		}
	}

	/**
	 * delete tasks with invalid position index
	 * (smaller than 0 or larger than max index)
	 * set error message 
	 */
	private void deleteWithInvalidPositionIndex() {
		state.setDisplayMessage(Constant.MESSAGE_INDEX_OUT_OF_BOUND);
	}


	/**
	 * delete tasks under invalid mode
	 * set error message 
	 */
	private void deleteUnderInvalidMode() {
		state.setDisplayMessage(Constant.MESSAGE_CLEAR_IN_WRONG_MODE);
	}
	
	
	/**
	 * delete tasks under start mode
	 * @param positionIndexLocal   position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 */
	
	private void deleteUnderStartMode(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> startingTasks = state.getTodaysTasks();

		if(positionIndexLocal >= startingTasks.size()){
			throw new IndexOutOfBoundsException();
		}

		Task toBeDeleted = startingTasks.get(positionIndexLocal);
		deleteTask(toBeDeleted);
		startingTasks.remove(toBeDeleted);
	}
	
	/**
	 * delete tasks under finished mode
	 * @param positionIndexLocal   position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in finished tasks list.
	 */

	private void deleteUnderFinishedMode(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> finishedTasks = state.getFinishedTasks();

		if(positionIndexLocal >= finishedTasks.size()){
			throw new IndexOutOfBoundsException();
		}

		finishedTasks.remove(positionIndexLocal);
	}

	/**
	 * delete tasks under search mode
	 * @param positionIndexLocal   position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in searched tasks list.
	 */
	private void deleteUnderSearchMode(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> searchedTasks = state.getSearchResultTasks();

		if(positionIndexLocal >= searchedTasks.size()){
			throw new IndexOutOfBoundsException();
		}

		Task toBeDeleted = searchedTasks.get(positionIndexLocal);
		deleteTask(toBeDeleted);
		searchedTasks.remove(positionIndexLocal);
	}
	
	/**
	 * delete tasks under deadline mode
	 * @param positionIndexLocal   position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in searched tasks list.
	 */
	private void deleteUnderDeadlineMode(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();

		if(positionIndexLocal >= deadlineTasks.size()){
			throw new IndexOutOfBoundsException();
		}

		Task toBeDeleted = deadlineTasks.get(positionIndexLocal);
		deleteTask(toBeDeleted);
	}

	/**
	 * delete tasks under floating mode
	 * @param positionIndexLocal   position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in searched tasks list.
	 */
	private void deletedUnderFloatingMode(int positionIndexLocal) throws IndexOutOfBoundsException {
		ArrayList<Task> floatingTasks = state.getFloatingTasks();

		if(positionIndexLocal >= floatingTasks.size()){
			throw new IndexOutOfBoundsException();
		}

		Task toBeDeleted = floatingTasks.get(positionIndexLocal);
		deleteTask(toBeDeleted);
	}

	/**
	 * delete tasks under all mode
	 * @param positionIndexLocal   position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in all tasks list.
	 */
	private void deleteUnderAllMode(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> allTasks = state.getAllTasks();

		if(positionIndexLocal >= allTasks.size()){
			throw new IndexOutOfBoundsException();
		}

		Task toBeDeleted = allTasks.get(positionIndexLocal);
		deleteTask(toBeDeleted);
	}

	/**
	 * delete the task from all task list, deadline task list and floating task list where applicable
	 * @param toBeDeleted   task to be deleted
	 */
	private void deleteTask(Task toBeDeleted) {
		ArrayList<Task> allTasks = state.getAllTasks();
		allTasks.remove(toBeDeleted);

		TaskType taskType = toBeDeleted.getTaskType();

		if(taskType == TaskType.FLOATING){
			ArrayList<Task> floatingTasks = state.getFloatingTasks();
			floatingTasks.remove(toBeDeleted);
		}

		if(taskType == TaskType.DEADLINE){
			ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
			deadlineTasks.remove(toBeDeleted);
		}
	}
	
	/**
	 * check and return the index of task to be ticked 
	 * @return position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is < 0.
	 */
	private int getAndValidatePositionIndex() throws IndexOutOfBoundsException{
		LogicUtils logicUtils = new LogicUtils(state);
		int localPositionIndex = logicUtils.getAndValidatePositionIndex();
		return localPositionIndex;
	}
	
}
```
###### \logic\LogicUtils.java
``` java
package logic;

import java.util.ArrayList;

import common.State;
import common.Task;

public class LogicUtils {
	
	private State state;
	
	public LogicUtils(State state) {
		this.state = state;
	}
	
	
	/**
	 * change the isDetailDisplayed attribute of every task to false 
	 * to collapse all tasks
	 */
	public void collapseAllTasks() {
		ArrayList<Task> allTasks = state.getAllTasks();
		for(int i = 0; i < allTasks.size(); i++){
			Task another = allTasks.get(i);
			another.setIsDetailDisplayed(false);
		}
		
		ArrayList<Task> finishedTasks = state.getFinishedTasks();
		for(int i = 0; i < finishedTasks.size(); i++){
			Task another = finishedTasks.get(i);
			another.setIsDetailDisplayed(false);
		}
	}
	
	/**
	 * check and return the index of task to be ticked 
	 * @return position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is < 0.
	 */
	public int getAndValidatePositionIndex() {
		int positionIndex = state.getPositionIndex();

		// Convert 1 base index to 0 base index
		int localPositionIndex = fromOneBaseToZeroBase(positionIndex);

		if(localPositionIndex < 0){
			throw new IndexOutOfBoundsException();
		}
		return localPositionIndex;
	}
	
	/**
	 * return a number that is 1 less than the input
	 * @param num   number to be subtracted
	 * @return subtracted number that is 1 less than the input
	 */
	private int fromOneBaseToZeroBase(int num) {
		int newNew = num - 1;
		return newNew;
	}
}
```
###### \logic\Operation.java
``` java
package logic;

public interface Operation {
	public boolean process();
}
```
###### \logic\SearchTasks.java
``` java
package logic;

import java.util.ArrayList;
import common.State;
import common.Task;
import common.ViewMode;

public class SearchTasks implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public SearchTasks(State state) {
		this.state = state;
	}
	
	
	/**
	 * Perform searching of all tasks on a set of Strings
	 *
	 * @return  boolean to indicate whether the addition is successful
	 */
	@Override
	public boolean process() {

		ArrayList<String> keysToSearch = state.getSearchKey();
		
		ArrayList<Task> searchedTasks = state.getSearchResultTasks();
		searchedTasks.clear();

		for (int i = 0 ; i < keysToSearch.size(); i++) {
			String key = keysToSearch.get(i);
			searchWord(key.toLowerCase(), searchedTasks);
		}
		
		state.setViewMode(ViewMode.SEARCH);
		collapseAllTasks();

		return true;
	}

	
	/**
	 * search all tasks and add all tasks that contain the keyword to search
	 * @param keyToSearch     String object to be searched
	 * @param searchedTasks   ArrayList that contains all the tasks searched
	 * @return  boolean to indicate whether the addition is successful
	 */
	private void searchWord(String keyToSearch, ArrayList<Task> searchedTasks) {
		ArrayList<Task> allTasks = state.getAllTasks();

		for(int i = 0; i < allTasks.size(); i++){
			Task task = allTasks.get(i);
			if(task.concatString().contains(keyToSearch) && !searchedTasks.contains(task)){
				searchedTasks.add(task);
			}
		}
	}
	
	/**
	 * change the isDetailDisplayed attribute of every task to false 
	 * to collapse all tasks
	 */
	private void collapseAllTasks() {
		LogicUtils logicUtils = new LogicUtils(state);
		logicUtils.collapseAllTasks();
	}

}
```
###### \logic\TickTask.java
``` java
package logic;

import java.util.ArrayList;

import common.Constant;
import common.State;
import common.Task;
import common.ViewMode;

public class TickTask implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public TickTask(State state) {
		this.state = state;
	}
	
	
	/**
	 * Perform ticking of tasks
	 * If the index are out of bound or tick under FINISHED, CONFIG, HELP or UNDEFINED mode
	 * return false
	 * 
	 * @return  boolean to indicate whether the addition is successful
	 */
	@Override
	public boolean process() {
		try {
			int localPositionIndex = getAndValidatePositionIndex();
	
			ViewMode viewMode = state.getViewMode();
			boolean isTickSuccessful;
			
			switch (viewMode) { 
				case FLOATING:
					isTickSuccessful = tickUnderFloatingMode(localPositionIndex);
					return isTickSuccessful;
				case DEADLINE:
					isTickSuccessful = tickUnderDeadlineMode(localPositionIndex);
					return isTickSuccessful;
				case ALL:
					isTickSuccessful = tickUnderAllMode(localPositionIndex);
					return isTickSuccessful;
				case SEARCH:
					isTickSuccessful = tickUnderSearchMode(localPositionIndex);
					return isTickSuccessful;
				case START:
					isTickSuccessful = tickUnderStartMode(localPositionIndex);
					return isTickSuccessful;
				case FINISHED:
					tickUnderInvalidMode();
					return false;
				case UNDEFINED:
					tickUnderInvalidMode();
					return false;
				case CONFIG:
					tickUnderInvalidMode();
					return false;
				case HELP:
					tickUnderInvalidMode();
					return false;
				default:
					return false;
			}	

		} catch (IndexOutOfBoundsException e){
			tickWithInvalidPositionIndex();
			return false;
		}
	}

	/**
	 * check and return the index of task to be ticked 
	 * @return position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is < 0.
	 */
	private int getAndValidatePositionIndex() throws IndexOutOfBoundsException{
		LogicUtils logicUtils = new LogicUtils(state);
		int localPositionIndex = logicUtils.getAndValidatePositionIndex();
		return localPositionIndex;
	}

	
	/**
	 * tick tasks with invalid position index
	 * (smaller than 0 or larger than max index)
	 * set error message 
	 */
	private void tickWithInvalidPositionIndex() {
		state.setDisplayMessage(Constant.MESSAGE_INDEX_OUT_OF_BOUND);
	}

	/**
	 * tick task under invalid mode
	 * set error message 
	 * 
	 */
	private void tickUnderInvalidMode() {
		state.setDisplayMessage(Constant.MESSAGE_CLEAR_IN_WRONG_MODE);
	}


	/**
	 * tick task under start mode
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 * @return a boolean to indicate whether tick is successful
	 */
	private boolean tickUnderStartMode(int positionIndexLocal) {
		// find the task in all tasks list
		Task toBeTicked = findTaskFromStartingTasks(positionIndexLocal);
		
		//tick the task 
		boolean isTickSuccessful = tickTask(toBeTicked);
		
		if(isTickSuccessful) {
			return true;
		} else {
			state.setDisplayMessage(Constant.MESSAGE_SYSTEM_FAILED_TO_TICK);
			return false;
		}
	}

	/**
	 * tick task under search mode
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 * @return a boolean to indicate whether tick is successful
	 */
	private boolean tickUnderSearchMode(int positionIndexLocal) {
		// find the task in all tasks list
		Task toBeTicked = findTaskFromSearchedTasks(positionIndexLocal);
		
		//tick the task 
		boolean isTickSuccessful = tickTask(toBeTicked);
		
		if(isTickSuccessful) {
			return true;
		} else {
			state.setDisplayMessage(Constant.MESSAGE_SYSTEM_FAILED_TO_TICK);
			return false;
		}
	}

	/**
	 * tick task under all mode
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 * @return a boolean to indicate whether tick is successful
	 */
	private boolean tickUnderAllMode(int positionIndexLocal) {
		// find the task in all tasks list
		Task toBeTicked = findTaskFromAllTasks(positionIndexLocal);
		
		//tick the task 
		boolean isTickSuccessful = tickTask(toBeTicked);
		
		if(isTickSuccessful) {
			return true;
		} else {
			state.setDisplayMessage(Constant.MESSAGE_SYSTEM_FAILED_TO_TICK);
			return false;
		}
	}

	
	/**
	 * tick task under deadline mode
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 * @return a boolean to indicate whether tick is successful
	 */
	private boolean tickUnderDeadlineMode(int positionIndexLocal) {
		// find the task in deadline tasks list
		Task toBeTicked = findTaskFromDeadlineTasks(positionIndexLocal);
		
		//tick the task 
		boolean isTickSuccessful = tickTask(toBeTicked);
		
		if(isTickSuccessful) {
			return true;
		} else {
			state.setDisplayMessage(Constant.MESSAGE_SYSTEM_FAILED_TO_TICK);
			return false;
		}
	}

	/**
	 * tick task under floating mode
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 * @return a boolean to indicate whether tick is successful
	 */
	private boolean tickUnderFloatingMode(int positionIndexLocal) {
		Task toBeTicked = findTaskFromFloatingTasks(positionIndexLocal);
		
		//tick the task 
		boolean isTickSuccessful = tickTask(toBeTicked);
		
		if(isTickSuccessful) {
			return true;
		} else {
			state.setDisplayMessage(Constant.MESSAGE_SYSTEM_FAILED_TO_TICK);
			return false;
		}
	}

	
	/**
	 * find task from starting task list
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @return the task if found in starting tasks
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 */
	private Task findTaskFromStartingTasks(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getTodaysTasks();

		if(positionIndexLocal >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeTicked = taskList.get(positionIndexLocal);
		return toBeTicked;
	}

	/**
	 * find task from searched task list
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @return the task if found in searched tasks
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in searched tasks list.
	 */
	private Task findTaskFromSearchedTasks(int localPositionIndex) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getSearchResultTasks();

		if(localPositionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeTicked = taskList.get(localPositionIndex);
		return toBeTicked;
	}
	
	/**
	 * find task from all task list
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @return the task if found in all tasks
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in all tasks list.
	 */
	private Task findTaskFromAllTasks(int localPositionIndex) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getAllTasks();

		if(localPositionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeTicked = taskList.get(localPositionIndex);
		return toBeTicked;
	}
	
	/**
	 * find task from deadline task list
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @return the task if found in deadline tasks
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in deadline tasks list.
	 */
	private Task findTaskFromDeadlineTasks(int localPositionIndex) throws IndexOutOfBoundsException {
		ArrayList<Task> taskList = state.getDeadlineTasks();

		if(localPositionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeTicked = taskList.get(localPositionIndex);
		return toBeTicked;
	}
	
	
	/**
	 * find task from floating task list
	 * @param positionIndexLocal   position of the task to be ticked in zero based index
	 * @return the task if found in floating tasks
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in all floating list.
	 */
	private Task findTaskFromFloatingTasks(int localPositionIndex) throws IndexOutOfBoundsException {
		ArrayList<Task> taskList = state.getFloatingTasks();

		if(localPositionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeTicked = taskList.get(localPositionIndex);
		return toBeTicked;
	}
	
	/**
	 * tick the task by removing the task and put it into finished task list
	 * @param toBeTicked    the task to be ticked
	 * @return a boolean to indicate whether tick is successful
	 */
	private boolean tickTask(Task toBeTicked) {
		ArrayList<Task> finishedTask = state.getFinishedTasks();
		finishedTask.add(toBeTicked);
		DeleteTask deleteTask = new DeleteTask(state);
		boolean isDeletedSuccessful = deleteTask.process();
		state.setViewMode(ViewMode.FINISHED);
		return isDeletedSuccessful;
	}

	
}

```
###### \logic\UntickTask.java
``` java
package logic;


import java.util.ArrayList;
import java.util.Collections;

import common.Constant;
import common.State;
import common.Task;
import common.TaskComparators;
import common.TaskType;
import common.ViewMode;

public class UntickTask implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public UntickTask(State state) {
		this.state = state;
	}
	
	
	/**
	 * Perform unticking of tasks
	 * If the index are out of bound or tick not under finished mode
	 * return false
	 * 
	 * @return  boolean to indicate whether the ticking is successful
	 */
	@Override
	public boolean process() {
		try {
			ViewMode viewMode = state.getViewMode();
			
			if(viewMode != ViewMode.FINISHED){
				state.setDisplayMessage(Constant.MESSAGE_UNTICK_IN_WRONG_MODE);
				return false;
			} else {
				int localPositionIndex = getAndValidatePositionIndex();
				Task taskToBeUnticked = state.getFinishedTasks().get(localPositionIndex);
				TaskType taskType = taskToBeUnticked.getTaskType();
				state.getFinishedTasks().remove(localPositionIndex);
				
				if(taskType == TaskType.DEADLINE){
					addDeadlineTask(taskToBeUnticked);
					return true;
				}
				
				if(taskType == TaskType.FLOATING){
					addFloatingTask(taskToBeUnticked);
					return true;
				}
			}
		} catch (IndexOutOfBoundsException e){
			untickWithInvalidPositionIndex();
			return false;
		}
		return false;
	}
	
	/**
	 * untick tasks with invalid position index
	 * (smaller than 0 or larger than max index)
	 * set error message 
	 */
	private void untickWithInvalidPositionIndex() {
		state.setDisplayMessage(Constant.MESSAGE_INDEX_OUT_OF_BOUND);
	}
	
	
	/**
	 * check and return the index of task to be ticked 
	 * @return position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is < 0.
	 */
	private int getAndValidatePositionIndex() throws IndexOutOfBoundsException{
		LogicUtils logicUtils = new LogicUtils(state);
		int localPositionIndex = logicUtils.getAndValidatePositionIndex();
		return localPositionIndex;
	}
	
	
	/**
	 * add a deadline task
	 * @param newTask
	 */
	private void addDeadlineTask(Task newTask) {
		addToDeadlineList(newTask);
		addToAllList(newTask);
		setCurrentModeTo(ViewMode.DEADLINE);
		updatePositionIndex(newTask, TaskType.DEADLINE);
	}

	/**
	 * add a floating task
	 * @param newTask
	 */
	private void addFloatingTask(Task newTask) {
		addToFloatingList(newTask);
		addToAllList(newTask);
		setCurrentModeTo(ViewMode.FLOATING);		
		updatePositionIndex(newTask, TaskType.FLOATING);
	}

	
	/**
	 * add new task to deadline task list in state
	 * @param newTask
	 */
	private void addToDeadlineList(Task newTask) {
		ArrayList<Task> taskList = state.getDeadlineTasks();
		taskList.add(newTask);	
		Collections.sort(taskList, TaskComparators.compareByEndDate);
	}

	/**
	 * add new task to floating task list in state
	 * @param newTask
	 */
	private void addToFloatingList(Task newTask) {
		ArrayList<Task> taskList = state.getFloatingTasks();
		taskList.add(newTask);
		Collections.sort(taskList, TaskComparators.compareByCreationDate);
	}

	
	/**
	 * add new task to all task list in state
	 * @param newTask
	 */
	private void addToAllList(Task newTask) {
		ArrayList<Task> allTasks = state.getAllTasks();
		allTasks.add(newTask);
		Collections.sort(allTasks, TaskComparators.compareByCreationDate);
	}
	
	/**
	 * update the positionIndex in the state to the newly added task
	 * @param newTask newly added task
	 * @param taskType type of newly added task
	 * only newTask of type DEADLINE or FLOATING are supposed to invoke this method
	 */
	private void updatePositionIndex(Task newTask, TaskType taskType) {
		if(taskType == TaskType.DEADLINE){
			int indexOfNewTask = state.getDeadlineTasks().indexOf(newTask);
			state.setPositionIndex(indexOfNewTask);
		}
		
		if(taskType == TaskType.FLOATING){
			int indexOfNewTask = state.getFloatingTasks().indexOf(newTask);
			state.setPositionIndex(indexOfNewTask);
		}
	}
	

	/**
	 * switch the view mode to viewMode
	 * @param viewMode new view mode to be displayed
	 */
	private void setCurrentModeTo(ViewMode viewMode) {
		state.setViewMode(viewMode);
		collapseAllTasks();
	}


	/**
	 * change the isDetailDisplayed attribute of every task to false 
	 * to collapse all tasks
	 */
	private void collapseAllTasks() {
		LogicUtils logicUtils = new LogicUtils(state);
		logicUtils.collapseAllTasks();
	}
	
	

	
}
```
###### \logic\UpdateTask.java
``` java
package logic;

import java.util.ArrayList;
import java.util.Collections;

import common.Constant;
import common.State;
import common.Task;
import common.TaskComparators;
import common.TaskType;
import common.ViewMode;

public class UpdateTask implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public UpdateTask(State state) {
		this.state = state;
	}
	
	
	/**
	 * Perform update of tasks
	 * If the index are out of bound or tick under FINISHED, CONFIG, HELP or UNDEFINED mode
	 * return false
	 * 
	 * @return  boolean to indicate whether the update is successful
	 */
	@Override
	public boolean process() {
		try {
			ViewMode viewMode = state.getViewMode();
			int positionIndexLocal = getAndValidatePositionIndex();
						
			switch (viewMode) { 
				case FLOATING:
					updateUnderFloatingMode(positionIndexLocal);
					return true;
				case DEADLINE:
					updateUnderDeadlineMode(positionIndexLocal);
					return true;
				case ALL:
					updateUnderAllMode(positionIndexLocal);
					return true;
				case SEARCH:
					updateUnderSearchMode(positionIndexLocal);
					return true;
				case START:
					updateUnderStartMode(positionIndexLocal);
					return true;
				case FINISHED:
					updateUnderFinishedMode(positionIndexLocal);
					return true;
				case UNDEFINED:
					updateUnderInvalidMode();
					return false;
				case CONFIG:
					updateUnderInvalidMode();
					return false;
				case HELP:
					updateUnderInvalidMode();
					return false;
				default:
					return false;
			}	

		} catch (IndexOutOfBoundsException e){
			updateWithInvalidPositionIndex();
			return false;
		}
	}

	
	/**
	 * tick tasks with invalid position index
	 * (smaller than 0 or larger than max index)
	 * set error message 
	 */
	private void updateWithInvalidPositionIndex() {
		state.setDisplayMessage(Constant.MESSAGE_INDEX_OUT_OF_BOUND);
	}
	
	/**
	 * tick task under invalid mode
	 * set error message 
	 * 
	 */
	private void updateUnderInvalidMode() {
		state.setDisplayMessage(Constant.MESSAGE_UPDATE_IN_WRONG_MODE);
	}
	
	/**
	 * update task under finished mode
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in finished tasks list.
	 */
	private void updateUnderFinishedMode(int positionIndexLocal) {
		Task toBeUpdated = findTaskFromFinishedTasks(positionIndexLocal);

		updateTask(toBeUpdated);
	}

	/**
	 * update task under start mode
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 */
	private void updateUnderStartMode(int positionIndexLocal) {
		Task toBeUpdated = findTaskFromStartingTasks(positionIndexLocal);

		updateTask(toBeUpdated);
	}

	/**
	 * update task under search mode
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in searched tasks list.
	 */
	private void updateUnderSearchMode(int positionIndexLocal) {
		Task toBeUpdated = findTaskFromSearchedTasks(positionIndexLocal);

		updateTask(toBeUpdated);
	}
	
	/**
	 * update task under all mode
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in all tasks list.
	 */
	private void updateUnderAllMode(int positionIndexLocal) {
		Task toBeUpdated = findTaskFromAllTasks(positionIndexLocal);
		updateTask(toBeUpdated);
	}

	/**
	 * update task under deadline mode
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in deadline tasks list.
	 */
	private void updateUnderDeadlineMode(int positionIndexLocal) {
		Task toBeUpdated = findTaskFromDeadlineTasks(positionIndexLocal);

		updateTask(toBeUpdated);
	}

	/**
	 * update task under floating mode
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in floating tasks list.
	 */
	private void updateUnderFloatingMode(int positionIndexLocal) {
		Task toBeUpdated = findTaskFromFloatingTasks(positionIndexLocal);

		updateTask(toBeUpdated);
	}
	
	/**
	 * update a task 
	 * @param task       the task that is to be updated
	 */
	private void updateTask(Task task){
		if(state.getIsContentChanged()){
			task.setContent(state.getContent());
		}
		
		if(state.getIsVenueChanged()){
			task.setVenue(state.getVenue());
		}
		
		if(state.getIsDetailChanged()){
			task.setDetail(state.getDetail());
		}
		
		if(state.getIsStartDateChanged()){
			task.setStartDate(state.getStartDate());
		}
		
		if(state.getIsEndDateChanged()){
			task.setEndDate(state.getEndDate());
			if(task.getTaskType() == TaskType.FLOATING){
				transferFromFloatToDeadline(task);
			}
			
			if(task.getTaskType() == null){
				transferFromDeadlineToFLoating(task);
			}
		}
		
		if(task.getTaskType() == TaskType.DEADLINE){
			state.setViewMode(ViewMode.DEADLINE);
		}
		
		if(task.getTaskType() == TaskType.FLOATING){
			state.setViewMode(ViewMode.FLOATING);
		}
	}

	/**
	 * find the task to be updated from floating tasks list to deadline taskslist
	 * task must be in floating tasks before transferring
	 * @param task   task to be transfered
	 * @return the task at postionIndexLocal position
	 */
	private void transferFromFloatToDeadline(Task task) {
		task.setTaskType(TaskType.DEADLINE);
		state.getFloatingTasks().remove(task);
		state.getDeadlineTasks().add(task);
		Collections.sort(state.getDeadlineTasks(), TaskComparators.compareByEndDate);
	}
	
	/**
	 * find the task to be updated from floating tasks list to deadline taskslist
	 * task must be in floating tasks before transferring
	 * @param task   task to be transfered
	 * @return the task at postionIndexLocal position
	 */
	private void transferFromDeadlineToFLoating(Task task) {
		task.setTaskType(TaskType.DEADLINE);
		state.getDeadlineTasks().remove(task);
		state.getFloatingTasks().add(task);
		Collections.sort(state.getDeadlineTasks(), TaskComparators.compareByEndDate);
	}
	
	/**
	 * find the task to be updated from finished tasks list
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in finished tasks list.
	 * @return the task at postionIndexLocal position
	 */
	private Task findTaskFromFinishedTasks(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getFinishedTasks();

		if(positionIndexLocal >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndexLocal);
		return toBeUpdated;
	}
	
	/**
	 * find the task to be updated from starting tasks list
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 * @return the task at postionIndexLocal position
	 */
	private Task findTaskFromStartingTasks(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getTodaysTasks();

		if(positionIndexLocal >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndexLocal);
		return toBeUpdated;
	}
	
	/**
	 * find the task to be updated from searched tasks list
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in searched tasks list.
	 * @return the task at postionIndexLocal position
	 */
	private Task findTaskFromSearchedTasks(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getSearchResultTasks();

		if(positionIndexLocal >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndexLocal);
		return toBeUpdated;
	}
	
	/**
	 * find the task to be updated from all tasks list
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in all tasks list.
	 * @return the task at postionIndexLocal position
	 */
	private Task findTaskFromAllTasks(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getAllTasks();

		if(positionIndexLocal >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndexLocal);
		return toBeUpdated;
	}

	
	/**
	 * find the task to be updated from deadline tasks list
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in deadline tasks list.
	 * @return the task at postionIndexLocal position
	 */
	private Task findTaskFromDeadlineTasks(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getDeadlineTasks();

		if(positionIndexLocal >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndexLocal);
		return toBeUpdated;
	}
	
	
	/**
	 * find the task to be updated from floating tasks list
	 * @param positionIndexLocal   position of the task to be updated in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in floating tasks list.
	 * @return the task at postionIndexLocal position
	 */
	private Task findTaskFromFloatingTasks(int positionIndexLocal) throws IndexOutOfBoundsException{
		ArrayList<Task> taskList = state.getFloatingTasks();

		if(positionIndexLocal >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndexLocal);
		return toBeUpdated;
	}
	
	
	/**
	 * check and return the index of task to be ticked 
	 * @return position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is < 0.
	 */
	private int getAndValidatePositionIndex() throws IndexOutOfBoundsException{
		LogicUtils logicUtils = new LogicUtils(state);
		int localPositionIndex = logicUtils.getAndValidatePositionIndex();
		return localPositionIndex;
	}

}
```
###### \logic\ViewTaskDetail.java
``` java
package logic;

import java.util.ArrayList;

import common.Constant;
import common.State;
import common.Task;
import common.ViewMode;

public class ViewTaskDetail implements Operation {
	//============================
	//       Attributes
	//============================
	private State state;

	
	//====================================
	//       Constructor and Initiliser
	//====================================
	
	public ViewTaskDetail(State state) {
		this.state = state;
	}
	
	
	/**
	 * Perform view tasks detail 
	 * toggle the isDetailDisplayed attribute of the selected task to 
	 * fold or collapse the task
	 * If the index are out of bound or view detail under CONFIG, HELP or UNDEFINED mode
	 * return false
	 * 
	 * @return  boolean to indicate whether the update is successful
	 */
	@Override
	public boolean process() {
		try {
			int localPositionIndex = getAndValidatePositionIndex();

			ViewMode viewMode = state.getViewMode();

			switch (viewMode) { 
				case FLOATING:
					viewUnderFloatingMode(localPositionIndex);
					return true;
				case DEADLINE:
					viewUnderDeadlineMode(localPositionIndex);
					return true;
				case ALL:
					viewUnderAllMode(localPositionIndex);
					return true;
				case SEARCH:
					viewUnderSearchMode(localPositionIndex);
					return true;
				case START:
					viewUnderStartMode(localPositionIndex);
					return true;
				case FINISHED:
					viewUnderFinishedMode(localPositionIndex);
					return false;
				case UNDEFINED:
					viewUnderInvalidMode();
					return false;
				case CONFIG:
					viewUnderInvalidMode();
					return false;
				case HELP:
					viewUnderInvalidMode();
					return false;
				default:
					return false;
			}	

		} catch (IndexOutOfBoundsException e){
			viewWithInvalidPositionIndex();
			return false;
		}
	}

	
	/**
	 * view detail with invalid position index
	 * (smaller than 0 or larger than max index)
	 * set error message 
	 */
	private void viewWithInvalidPositionIndex() {
		state.setDisplayMessage(Constant.MESSAGE_INDEX_OUT_OF_BOUND);
	}

	/**
	 * view detail under invalid mode
	 * set error message 
	 * 
	 */
	private void viewUnderInvalidMode() {
		state.setDisplayMessage(Constant.MESSAGE_DELETE_IN_WRONG_MODE);
	}
	
	
	/**
	 * view task detail under finished mode
	 * @param positionIndex   position of the task to be folded/collapsed in zero based index
	 */
	private void viewUnderFinishedMode(int positionIndex) {
		Task toBeDisplayed = findTaskFromFinishedTasks(positionIndex);
		viewTaskDetail(toBeDisplayed);
	}
	
	/**
	 * view task detail under all mode
	 * @param positionIndex   position of the task to be folded/collapsed in zero based index
	 */
	private void viewUnderAllMode(int positionIndex) {
		Task toBeDisplayed = findTaskFromAllTasks(positionIndex);
		viewTaskDetail(toBeDisplayed);
	}

	/**
	 * view task detail under search mode
	 * @param positionIndex   position of the task to be folded/collapsed in zero based index
	 */
	private void viewUnderSearchMode(int positionIndex) {
		Task toBeUpdated = findTaskFromSearchedTasks(positionIndex);
		viewTaskDetail(toBeUpdated);
	}

	/**
	 * view task detail under start mode
	 * @param positionIndex   position of the task to be folded/collapsed in zero based index
	 */
	private void viewUnderStartMode(int positionIndex) {
		Task toBeUpdated = findTaskFromStartingTasks(positionIndex);
		viewTaskDetail(toBeUpdated);
	}
	
	/**
	 * view task detail under deadline mode
	 * @param positionIndex   position of the task to be folded/collapsed in zero based index
	 */
	private void viewUnderDeadlineMode(int positionIndex) {
		Task toBeUpdated = findTaskFromDeadlineTasks(positionIndex);

		viewTaskDetail(toBeUpdated);
	}

	/**
	 * view task detail under floating mode
	 * @param positionIndex   position of the task to be folded/collapsed in zero based index
	 */
	private void viewUnderFloatingMode(int positionIndex) {
		Task toBeUpdated = findTaskFromFloatingTasks(positionIndex);

		viewTaskDetail(toBeUpdated);
	}

	/**
	 * unfold a task or fold a task to view its detail
	 * fold if it is collapsed and collapse if it is folded
	 * @param task       the task that is to be folded/collapsed
	 */
	private void viewTaskDetail(Task task){
		boolean currentDisplayStatus = task.getIsDetailDisplayed();
		boolean changedToDisplayStatus = !currentDisplayStatus;
		task.setIsDetailDisplayed(changedToDisplayStatus);
	}
	
	/**
	 * find task from all tasks list
	 * @param positionIndex   position of the task to be found in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in all tasks list.
	 */
	private Task findTaskFromAllTasks(int positionIndex) {
		ArrayList<Task> taskList = state.getAllTasks();

		if(positionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndex);
		return toBeUpdated;
	}
	
	/**
	 * find task from deadline tasks list
	 * @param positionIndex   position of the task to be found in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in deadline tasks list.
	 */
	private Task findTaskFromDeadlineTasks(int positionIndex) {
		ArrayList<Task> taskList = state.getDeadlineTasks();

		if(positionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndex);
		return toBeUpdated;
	}
	
	/**
	 * find task from all floating list
	 * @param positionIndex   position of the task to be found in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in floating tasks list.
	 */
	private Task findTaskFromFloatingTasks(int positionIndex) {
		ArrayList<Task> taskList = state.getFloatingTasks();

		if(positionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndex);
		return toBeUpdated;
	}
	
	/**
	 * find task from searched tasks list
	 * @param positionIndex   position of the task to be found in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in searched tasks list.
	 */
	private Task findTaskFromSearchedTasks(int positionIndex) {
		ArrayList<Task> taskList = state.getSearchResultTasks();

		if(positionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndex);
		return toBeUpdated;
	}
	
	/**
	 * find task from starting tasks list
	 * @param positionIndex   position of the task to be found in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in starting tasks list.
	 */
	private Task findTaskFromStartingTasks(int positionIndex) {
		ArrayList<Task> taskList = state.getTodaysTasks();

		if(positionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndex);
		return toBeUpdated;
	}
	
	/**
	 * find task from finished tasks list
	 * @param positionIndex   position of the task to be found in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is > max index in finished tasks list.
	 */
	private Task findTaskFromFinishedTasks(int positionIndex) {
		ArrayList<Task> taskList = state.getFinishedTasks();

		if(positionIndex >= taskList.size()){
			throw new IndexOutOfBoundsException();	
		}

		Task toBeUpdated = taskList.get(positionIndex);
		return toBeUpdated;
	}
	
	
	/**
	 * check and return the index of task to be ticked 
	 * @return position of the task to be deleted in zero based index
	 * @throws IndexOutOfBoundsException  If positionIndexLocal is < 0.
	 */
	private int getAndValidatePositionIndex() throws IndexOutOfBoundsException{
		LogicUtils logicUtils = new LogicUtils(state);
		int localPositionIndex = logicUtils.getAndValidatePositionIndex();
		return localPositionIndex;
	}

}
```
###### \model\WallistModel.java
``` java
package model;

import java.util.EmptyStackException;
import java.util.Stack;
import common.*;
import logic.AddTask;
import logic.ChangeViewMode;
import logic.ClearTask;
import logic.Config;
import logic.DeleteTask;
import logic.Help;
import logic.LogicUtils;
import logic.SearchTasks;
import logic.TickTask;
import logic.UntickTask;
import logic.UpdateTask;
import logic.ViewTaskDetail;
import parser.Parser;
import storage.FileManagement;
import storage.Storage;
import java.util.logging.*;

public class WallistModel{
	
	//============================
	//       Attributes
	//============================
	
	private Storage storage;
	private Parser parser;
	private State state;
	private AddTask addTask;
	private LogicUtils logicUtils;
	private DeleteTask deleteTask;
	private TickTask tickTask;
	private UntickTask untickTask;
	private UpdateTask updateTask;
	private ClearTask clearTask;
	private Help help;
	private Config config;
	private SearchTasks searchTasks;
	private ChangeViewMode changeViewMode;
	private ViewTaskDetail viewTaskDetail;
	public Stack<State> stateHistory, stateFuture ;
	
	// logger
	private final static Logger LOGGER = Logger.getLogger(FileManagement.class.getName());
	
	// logging message displayed
	private static final String PARSER_FAILURE = "User input is not succesfully parsed!";
	private static final String PARSER_RUNNING = "Start to parse the user input...";
	
	//========================
	//       Constructor 
	//========================
	
	public WallistModel(){
		initialiseState(); // state must be initialised first
		initialiseLogic();
		initialiseStorage();
		initialiseParser();
		initialiseStateTracker();
	}
	
	//========================
	//       Functions 
	//========================
	
	/**
	 * This method takes in the actual user input and execute functions accordingly
	 * @param inputString
	 * @return whether it is successfully executed
	 */
	public boolean processInputString(String inputString){
		LOGGER.log(Level.INFO, PARSER_RUNNING);
		boolean isParsed = isSuccessfullyParsed(inputString);
		if (!isParsed) {
			LOGGER.log(Level.WARNING, PARSER_FAILURE);
			state.incErrorFrequency();
			return false;
		} else {
			state.resetErrorFrequency();
			boolean isExecutionSuccessful = executeInput();
			if(isExecutionSuccessful){
				displaySuccessfulMessage();
			}
			return isExecutionSuccessful;
		}
	}

	private void displaySuccessfulMessage() {
		state.setDisplayMessage(Constant.MESSAGE_SUCCESS);
	}
	
	//===========================
	//       Helper functions 
	//===========================
	
	/**
	 * This method initialises the initial state
	 */
	private void initialiseStateTracker() {
		stateHistory.push(state.deepCopy());
	}
	
	/**
	 * This method initialises the Parser
	 */
	private void initialiseParser() {
		parser = new Parser(state);
	}

	/**
	 * This method initialises the Storage
	 */
	private void initialiseStorage() {
		storage = new Storage(state);
		storage.executeLoadState();
		logicUtils.collapseAllTasks();
	}
	
	public void resetState(){
		this.state = new State();
	}
	public void resetStorage(){
		this.storage = new Storage(new State());
	}
	/**
	 * This method initialises the State related objects
	 */
	private void initialiseState() {
		state = new State();
		stateHistory = new Stack<State>();
		stateFuture = new Stack<State>();
	}

	/**
	 * This method initialises the Logic components
	 */
	private void initialiseLogic() {
		addTask = new AddTask(state);
		deleteTask = new DeleteTask(state);
		tickTask = new TickTask(state);
		untickTask = new UntickTask(state);
		updateTask = new UpdateTask(state);
		clearTask = new ClearTask(state);
		searchTasks = new SearchTasks(state);
		config = new Config(state, storage);
		changeViewMode = new ChangeViewMode(state);
		viewTaskDetail = new ViewTaskDetail(state);
		logicUtils = new LogicUtils(state);
		help = new Help(state);
	}
	
	/**
	 * This method passes the state to GUI
	 * @return the current State object
	 */
	public State getState(){
		return state;
	}
	
	/**
	 * This method checks whether the input String can be successfully parsed
	 * @param inputString
	 * @return
	 */
	private boolean isSuccessfullyParsed(String inputString) {
		state.setUserInput(inputString); // store input into state
		boolean isParsed = parser.processInput();
		boolean isValid = state.getIsValid();
		boolean isSuccesfullyParsed = isParsed && isValid;
		return isSuccesfullyParsed;
	}
	
	/**
	 * This method executes the commands using the information stored in the State object
	 * @return whether it is successful
	 */
	private boolean executeInput() {
		boolean isRunningSuccessful;
		try {
			isRunningSuccessful = running();
		} catch (EmptyStackException e){
			LOGGER.log(Level.WARNING, PARSER_FAILURE,e);
			state.setDisplayMessage(Constant.MESSAGE_EMPTY_STACK);
			return false;
		} catch (Exception e){
			LOGGER.log(Level.WARNING, PARSER_FAILURE,e);
			return false;
		}
		return isRunningSuccessful;
	}
	
	public boolean running() throws EmptyStackException{
		CommandType commandType = state.getCommandType();
		boolean isRunningSuccessful = false;
		
		switch (commandType) {
			case ADD :
				isRunningSuccessful = addTask.process();
				stateHistory.push(state.deepCopy());
				break;
			case DELETE :
				isRunningSuccessful = deleteTask.process();
				stateHistory.push(state.deepCopy());
				break;
			case TICK :
				isRunningSuccessful = tickTask.process();
				stateHistory.push(state.deepCopy());
				break;
			case UNTICK :
				isRunningSuccessful = untickTask.process();
				stateHistory.push(state.deepCopy());
				break;
			case UPDATE :
				isRunningSuccessful = updateTask.process();
				stateHistory.push(state.deepCopy());
				break;
			case CLEAR :
				isRunningSuccessful = clearTask.process();
				stateHistory.push(state.deepCopy());
				break;
			case SEARCH :
				isRunningSuccessful = searchTasks.process();
				break;
			case UNDO :
				isRunningSuccessful = runningUndo();
				return isRunningSuccessful;
			case REDO :
				isRunningSuccessful = runningRedo();
				return isRunningSuccessful;
			case DETAIL :
				isRunningSuccessful = viewTaskDetail.process();
				break;
			case CHANGEMODE :
				isRunningSuccessful = changeViewMode.process();
				break;
			case CONFIG :
				isRunningSuccessful = config.process();
				stateHistory.push(state.deepCopy());
				break;
			case HELP :
				isRunningSuccessful = help.process();
				break;
			case EXIT :
				isRunningSuccessful = true;
			default:
				break;
		}
		storage.executeSaveConfig();
		storage.executeSaveState();
		return isRunningSuccessful;
	}
	
	/*
	 * reverse the state to last state
	 * @return a boolean to indicate whether undo is successful
	 */
	private boolean runningUndo() throws EmptyStackException{
		if(stateHistory.size() <= 1){
			throw new EmptyStackException();
		}
		State currentCopy = stateHistory.peek();
		stateFuture.push(currentCopy.deepCopy());
		stateHistory.pop();
		state.recoverFrom(stateHistory.peek());
		return true;
	}
	
	/*
	 * reverse the state to next state
	 * @return a boolean to indicate whether redo is successful
	 */
	private boolean runningRedo() throws EmptyStackException {
		if(stateFuture.isEmpty()){
			throw new EmptyStackException();
		}
		State future = stateFuture.peek();
		state.recoverFrom(future);
		stateHistory.push(future.deepCopy());
		stateFuture.pop();
		return true;
	}
	
	
	//accessor for testing
	public Storage getStorage(){
		return storage;
	}

	public Parser getParser(){
		return parser;
	}
	
	public AddTask getAddTask(){
		return addTask;
	}
	
	public DeleteTask getDeleteTask(){
		return deleteTask;
	}
	
	public TickTask getTickTask(){
		return tickTask;
	}
	
	public UntickTask getUntickTask(){
		return untickTask;
	}
	
	public UpdateTask getUpdateTask(){
		return updateTask;
	}
	
	public ClearTask getClearTask(){
		return clearTask;
	}

	public Help getHelp(){
		return help;
	}
	
	public Config getConfig(){
		return config;
	}
	
	public SearchTasks getSearchTasks(){
		return searchTasks;
	}
	
	public ChangeViewMode getChangeViewMode(){
		return changeViewMode;
	}
	
	public ViewTaskDetail getViewTaskDetail(){
		return viewTaskDetail;
	}
	
	public LogicUtils getLogicUtils(){
		return logicUtils;
	}
}













```
###### \testing\AddTaskTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import model.WallistModel;

public class AddTaskTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		AddTask addTask = wm.getAddTask();

		// clear the state before testing
	    clearState(state);
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
	    	    	    
	    //successful cases:
	    //add a deadline task and test
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		testingDeadlineTask(state, startTest, endTestSecond, "A");
        
		//add a floating task and test
		createFloatingTaskState(state, startTest, addTask, "B");
		testFloatingTask(state, startTest, "B");
		

		//more testing on ordering of deadline task
		/*
		 * The correct list of deadline tasklist should be : (content , endDate)
		 * C 17 MAR 6 00:00
		 * A 19 MAR 6 00:00
		 * D 20 MAR 6 00:00
		 * Testing focus on the first and last instantce
		 */
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "D");
		testDeadlineTaskOrdering(state, startTest,endTestFirst, endTestThird, "C", "D");

	}

	private void testDeadlineTaskOrdering(State state, Date start, Date earliest, Date latest, 
										  String earliestContent, String LastestContent){
		// check the all task list
		Task newTask = state.getDeadlineTasks().get(0);
		assertEquals(earliestContent, newTask.getContent());
		assertEquals("testingVenue", newTask.getVenue());
		assertEquals("testingDetail", newTask.getDetail());
		assertEquals(TaskType.DEADLINE, newTask.getTaskType());
		assertEquals(start, newTask.getStartDate());
		assertEquals(earliest, newTask.getEndDate());

		// check floating task list
		Task newTask2 = state.getDeadlineTasks().get(state.getDeadlineTasks().size() - 1);
		assertEquals(LastestContent, newTask2.getContent());
		assertEquals("testingVenue", newTask2.getVenue());
		assertEquals("testingDetail", newTask2.getDetail());
		assertEquals(TaskType.DEADLINE, newTask2.getTaskType());
		assertEquals(start, newTask2.getStartDate());
		assertEquals(latest, newTask2.getEndDate());

	}
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}


	
	private void testFloatingTask(State state, Date start, String content) {

		// check the all task list
		Task newTask = state.getAllTasks().get(0);
		assertEquals(content, newTask.getContent());
		assertEquals("testingVenue", newTask.getVenue());
		assertEquals("testingDetail", newTask.getDetail());
		assertEquals(TaskType.FLOATING, newTask.getTaskType());
		assertEquals(start, newTask.getStartDate());
		assertEquals(null, newTask.getEndDate());

		// check floating task list
		Task newTask2 = state.getFloatingTasks().get(0);
		assertEquals(content, newTask2.getContent());
		assertEquals("testingVenue", newTask2.getVenue());
		assertEquals("testingDetail", newTask2.getDetail());
		assertEquals(TaskType.FLOATING, newTask2.getTaskType());
		assertEquals(start, newTask2.getStartDate());
		assertEquals(null, newTask2.getEndDate());

	}

	private void createFloatingTaskState(State state, Date start, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("testingVenue");
		state.setIsDetailChanged(true);
		state.setDetail("testingDetail");
		state.setTaskType(TaskType.FLOATING);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);

		state.setIsEndDateChanged(false);
		state.setEndDate(null);
		
		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.FLOATING, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);
	}

	private void testingDeadlineTask(State state,Date start, Date end, String content) {
		// check from all task list
		Task newTask = state.getAllTasks().get(0);
		assertEquals(content, newTask.getContent());
		assertEquals("testingVenue", newTask.getVenue());
		assertEquals("testingDetail", newTask.getDetail());
		assertEquals(TaskType.DEADLINE, newTask.getTaskType());
		assertEquals(start, newTask.getStartDate());
		assertEquals(end, newTask.getEndDate());

		// check floating task list
		Task newTask2 = state.getDeadlineTasks().get(0);
		assertEquals(content, newTask2.getContent());
		assertEquals("testingVenue", newTask2.getVenue());
		assertEquals("testingDetail", newTask2.getDetail());
		assertEquals(TaskType.DEADLINE, newTask2.getTaskType());
		assertEquals(start, newTask2.getStartDate());
		assertEquals(end, newTask2.getEndDate());

	}

	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("testingVenue");
		state.setIsDetailChanged(true);
		state.setDetail("testingDetail");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}

}
```
###### \testing\ChangeViewModeTest.java
``` java
package testing;

import static org.junit.Assert.*;

import org.junit.Test;

import common.State;
import common.ViewMode;
import logic.ChangeViewMode;
import model.WallistModel;

public class ChangeViewModeTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		ChangeViewMode changeViewMode = wm.getChangeViewMode();

		//Test change view mode to different mode 
		//Successful cases
		testWithNewViewMode(ViewMode.ALL, state, changeViewMode);
		testWithNewViewMode(ViewMode.FLOATING, state, changeViewMode);
		testWithNewViewMode(ViewMode.DEADLINE, state, changeViewMode);
		testWithNewViewMode(ViewMode.CONFIG, state, changeViewMode);
		testWithNewViewMode(ViewMode.FINISHED, state, changeViewMode);
		testWithNewViewMode(ViewMode.HELP, state, changeViewMode);
		testWithNewViewMode(ViewMode.START, state, changeViewMode);
		testWithNewViewMode(ViewMode.ALL, state, changeViewMode);
		
		//Failure cases
		//cannot view search(meaningless)
		testViewSearch(state, changeViewMode);

	}

	private void testViewSearch(State state, ChangeViewMode changeViewMode) {
		state.setNewViewMode(ViewMode.SEARCH);
		boolean isChangeSuccessful = changeViewMode.process();
		assertEquals(false, isChangeSuccessful);
	}

	private void testWithNewViewMode(ViewMode newView, State state, ChangeViewMode changeViewMode){
		changeNewViewModeInStateTo(state, changeViewMode, newView);
		testChangedViewMode(state, newView);
	}
	
	private void testChangedViewMode(State state, ViewMode newView) {
		assertEquals(newView, state.getViewMode());
	}

	private void changeNewViewModeInStateTo(State state, ChangeViewMode changeViewMode, ViewMode newView) {
		state.setNewViewMode(newView);
		boolean isChangeSuccessful = changeViewMode.process();
		assertEquals(true, isChangeSuccessful);
	}

}
```
###### \testing\ClearTaskTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.ViewMode;
import logic.AddTask;
import logic.ClearTask;
import logic.SearchTasks;
import logic.TickTask;
import model.WallistModel;

public class ClearTaskTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		ClearTask clearTask = wm.getClearTask();
		AddTask addTask = wm.getAddTask();
		SearchTasks searchTask = wm.getSearchTasks();
		TickTask tickTask = wm.getTickTask();
	    //Clear all tasks list for testing
		clearState(state);

		int taskNum = 10, numToTick = 5;
		
		// Add taskNum of floating task and clear under floating mode
		addFloatingTasks(state, addTask, taskNum);
		clearUnderMode(state, clearTask, ViewMode.FLOATING);
		assertEquals(0, state.getFloatingTasks().size());
		assertEquals(0, state.getAllTasks().size());

		// Add taskNum of deadline task and clear under floating mode
		addDeadlineTasks(state, addTask, taskNum);
		clearUnderMode(state, clearTask, ViewMode.DEADLINE);
		assertEquals(0, state.getDeadlineTasks().size());
		assertEquals(0, state.getAllTasks().size());

		// Add taskNum of deadline task and clear under all mode
		addDeadlineTasks(state, addTask, taskNum);
		clearUnderMode(state, clearTask, ViewMode.ALL);
		assertEquals(0, state.getDeadlineTasks().size());
		assertEquals(0, state.getAllTasks().size());

		// Add taskNum of floating task and clear under search mode
		addDeadlineTasks(state, addTask, taskNum);
		addSearchedTasks(state, searchTask);
		clearUnderMode(state, clearTask, ViewMode.SEARCH);
		assertEquals(0, state.getSearchResultTasks().size());

		// Clear all tasks and
		// Add taskNum of floating task, tick numToTick tasks under All mode
		// and clear under finished mode
		clearUnderMode(state, clearTask, ViewMode.ALL);
		addFloatingTasks(state, addTask, taskNum);
		addFinishedTasks(state, tickTask, taskNum, numToTick);
		clearUnderMode(state, clearTask, ViewMode.FINISHED);
		assertEquals(0, state.getFinishedTasks().size());
		
		//Now test clearing in wrong mode
		clearInWrongMode(state, clearTask, ViewMode.CONFIG);
		clearInWrongMode(state, clearTask, ViewMode.HELP);
		clearInWrongMode(state, clearTask, ViewMode.UNDEFINED);
		
	}

	private void clearInWrongMode(State state, ClearTask clearTask, ViewMode vm) {
		state.setViewMode(vm);
		boolean isClearSuccessful = clearTask.process();
		assertEquals(false, isClearSuccessful);
	}

	private void clearUnderMode(State state, ClearTask clearTask, ViewMode vm) {
		state.setViewMode(vm);
		boolean isClearSuccessful = clearTask.process();
		assertEquals(true, isClearSuccessful);
	}

	private void addFinishedTasks(State state, TickTask tickTask, int a, int b) {
		state.setPositionIndex(1);
		state.setViewMode(ViewMode.FLOATING);
		for(int i = 0; i < b; i++){
			tickTask.process();
		}
		assertEquals(b, state.getFinishedTasks().size());
		assertEquals(a - b, state.getAllTasks().size());
	}

	private void addSearchedTasks(State state, SearchTasks searchTask) {
		ArrayList<String> dummySearch = new ArrayList<String>();
		dummySearch.add("");
		state.setSearchKey(dummySearch);
		searchTask.process();
		assertEquals(state.getAllTasks().size(), state.getSearchResultTasks().size());
	}

	private void addDeadlineTasks(State state, AddTask addTask, int a) {
		state.setIsEndDateChanged(true);
		state.setEndDate(new Date(System.currentTimeMillis()));
		
		for(int i = 0; i < a; i++){
			addTask.process();
		}
		assertEquals(a, state.getDeadlineTasks().size());
		assertEquals(a, state.getAllTasks().size());
	}

	private void addFloatingTasks(State state, AddTask addTask, int a) {
		state.setIsEndDateChanged(false);
		for(int i = 0; i < a; i++){
			addTask.process();
		}
		assertEquals(a, state.getAllTasks().size());
		assertEquals(a, state.getFloatingTasks().size());
	}
	
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}

}
```
###### \testing\DeleteTaskTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import logic.DeleteTask;
import model.WallistModel;

public class DeleteTaskTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		DeleteTask deleteTask = wm.getDeleteTask();
		AddTask addTask = wm.getAddTask();
		clearState(state);
		
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
		
		
		//more testing on ordering of deadline task
		/*
		 * The correct list of deadline tasklist should be : (content , endDate)
		 * C 17 MAR 6 00:00
		 * A 19 MAR 6 00:00
		 * D 20 MAR 6 00:00
		 * Testing focus on the first and last instantce
		 */
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "D");
		
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());

		
		state.setViewMode(ViewMode.DEADLINE);
		state.setPositionIndex(1);
		boolean isDeleteSuccessful = deleteTask.process();
		assertEquals(true, isDeleteSuccessful);
		assertEquals(endTestSecond, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(1).getEndDate());

	}
	
	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("testingVenue");
		state.setIsDetailChanged(true);
		state.setDetail("testingDetail");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}
	
	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
```
###### \testing\LogicUtilsTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import logic.LogicUtils;
import model.WallistModel;

public class LogicUtilsTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		LogicUtils logicUtils = wm.getLogicUtils();
		AddTask addTask = wm.getAddTask();
		
		testGetAndValidatePositionIndex(state, logicUtils);
	
		// clear the state before testing
	    clearState(state);
	    
		testCollapseAllTasks(state, logicUtils, addTask);

	}

	private void testCollapseAllTasks(State state, LogicUtils logicUtils, AddTask addTask) {
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
	    	
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "D");
		
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
		for(int i = 0; i < deadlineTasks.size(); i++){
			deadlineTasks.get(i).setIsDetailDisplayed(true);
		}
		logicUtils.collapseAllTasks();
		for(int i = 0; i < deadlineTasks.size(); i++){
			assertEquals(false, deadlineTasks.get(i).getIsDetailDisplayed());
		}
	}

	private void testGetAndValidatePositionIndex(State state, LogicUtils logicUtils) {
		state.setPositionIndex(2);
		assertEquals(1, logicUtils.getAndValidatePositionIndex());

		boolean isErrorThrown = false;
		try {
			state.setPositionIndex(0);
			logicUtils.getAndValidatePositionIndex();
		} catch (IndexOutOfBoundsException e){
			isErrorThrown = true;
		}
		assertEquals(true, isErrorThrown);
	}

	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("testingVenue");
		state.setIsDetailChanged(true);
		state.setDetail("testingDetail");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}
	
	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}
}
```
###### \testing\SearchTasksTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import logic.SearchTasks;
import model.WallistModel;

public class SearchTasksTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		SearchTasks searchTask = wm.getSearchTasks();
		AddTask addTask = wm.getAddTask();
		clearState(state);
		
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
		
		
		//more testing on ordering of deadline task
		/*
		 * The correct list of deadline tasklist should be : (content , endDate)
		 * C 17 MAR 6 00:00
		 * A 19 MAR 6 00:00
		 * D 20 MAR 6 00:00
		 * Testing focus on the first and last instantce
		 */
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "unique");
		
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());
		
		
		assertEquals("A", deadlineTasks.get(1).getContent());

		ArrayList<String> keywords = new ArrayList<String>();
		keywords.add("unique");
		state.setSearchKey(keywords);
		searchTask.process();
		assertEquals(ViewMode.SEARCH, state.getViewMode());
		assertEquals(1, state.getSearchResultTasks().size());
		assertEquals("unique", state.getSearchResultTasks().get(0).getContent());
		assertEquals(endTestThird, state.getSearchResultTasks().get(0).getEndDate());

	}
	

	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("");
		state.setIsDetailChanged(true);
		state.setDetail("");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}
	
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}
	
	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
```
###### \testing\TickTaskTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import logic.TickTask;
import model.WallistModel;

public class TickTaskTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		TickTask ticktask = wm.getTickTask();
		AddTask addTask = wm.getAddTask();
		clearState(state);
		
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
		
		
		//more testing on ordering of deadline task
		/*
		 * The correct list of deadline tasklist should be : (content , endDate)
		 * C 17 MAR 6 00:00
		 * A 19 MAR 6 00:00
		 * D 20 MAR 6 00:00
		 * Testing focus on the first and last instantce
		 */
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "unique");
		
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());
		
		
		state.setViewMode(ViewMode.DEADLINE);
		state.setPositionIndex(1);
		boolean isTickSuccessful = ticktask.process();
		assertEquals(true, isTickSuccessful);
		assertEquals(ViewMode.FINISHED, state.getViewMode());
		assertEquals(1, state.getFinishedTasks().size());
		assertEquals("C", state.getFinishedTasks().get(0).getContent());


	}
	

	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("");
		state.setIsDetailChanged(true);
		state.setDetail("");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}
	
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}
	
	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
```
###### \testing\UntickTaskTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import logic.TickTask;
import logic.UntickTask;
import model.WallistModel;

public class UntickTaskTest {


	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		TickTask ticktask = wm.getTickTask();
		UntickTask untickTask = wm.getUntickTask();
		AddTask addTask = wm.getAddTask();
		clearState(state);
		
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
		
		
		//more testing on ordering of deadline task
		/*
		 * The correct list of deadline tasklist should be : (content , endDate)
		 * C 17 MAR 6 00:00
		 * A 19 MAR 6 00:00
		 * D 20 MAR 6 00:00
		 * Testing focus on the first and last instantce
		 */
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "unique");
		
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());
		
		
		state.setViewMode(ViewMode.DEADLINE);
		state.setPositionIndex(1);
		boolean isTickSuccessful = ticktask.process();
		assertEquals(true, isTickSuccessful);
		assertEquals(ViewMode.FINISHED, state.getViewMode());
		assertEquals(1, state.getFinishedTasks().size());
		assertEquals("C", state.getFinishedTasks().get(0).getContent());

		state.setViewMode(ViewMode.FINISHED);
		state.setPositionIndex(1);
		boolean isUntickSuccessful = untickTask.process();
		assertEquals(true, isUntickSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());
		assertEquals(0, state.getFinishedTasks().size());
		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());
		

	}
	

	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("");
		state.setIsDetailChanged(true);
		state.setDetail("");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}
	
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}
	
	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}

```
###### \testing\UpdateTaskTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import logic.UpdateTask;
import model.WallistModel;

public class UpdateTaskTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		UpdateTask updateTask = wm.getUpdateTask();
		AddTask addTask = wm.getAddTask();
		clearState(state);
		
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
		
		
		//more testing on ordering of deadline task
		/*
		 * The correct list of deadline tasklist should be : (content , endDate)
		 * C 17 MAR 6 00:00
		 * A 19 MAR 6 00:00
		 * D 20 MAR 6 00:00
		 * Testing focus on the first and last instantce
		 */
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "unique");
		
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());
		
		// update second task
		state.setViewMode(ViewMode.DEADLINE);
		state.setPositionIndex(2);
		state.setIsContentChanged(true);
		state.setContent("newContent");
		state.setIsEndDateChanged(false);
		state.setIsDetailChanged(false);
		state.setIsVenueChanged(false);
		state.setIsStartDateChanged(false);
		boolean isUpdateSuccessful = updateTask.process();
		assertEquals(true, isUpdateSuccessful);

		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());
		
		assertEquals("newContent", deadlineTasks.get(1).getContent());

	}
	

	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("");
		state.setIsDetailChanged(true);
		state.setDetail("");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}
	
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}
	
	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}
```
###### \testing\ViewTaskDetailTest.java
``` java
package testing;

import static org.junit.Assert.*;

import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;

import org.junit.Test;

import common.State;
import common.Task;
import common.TaskType;
import common.ViewMode;
import logic.AddTask;
import logic.ViewTaskDetail;
import model.WallistModel;

public class ViewTaskDetailTest {

	@Test
	public void test() {
		WallistModel wm = new WallistModel();
		State state = wm.getState();
		ViewTaskDetail viewTaskDetail = wm.getViewTaskDetail();
		AddTask addTask = wm.getAddTask();
		clearState(state);
		
		Date startTest = stringToDate("18 MAR 6 00:00");
		Date endTestSecond = stringToDate("19 MAR 6 00:00");
		Date endTestFirst = stringToDate("17 MAR 6 00:00");
		Date endTestThird = stringToDate("20 MAR 6 00:00");
		
		
		//more testing on ordering of deadline task
		/*
		 * The correct list of deadline tasklist should be : (content , endDate)
		 * C 17 MAR 6 00:00
		 * A 19 MAR 6 00:00
		 * D 20 MAR 6 00:00
		 * Testing focus on the first and last instantce
		 */
		createDeadlineTaskState(state, startTest, endTestSecond, addTask, "A");
		createDeadlineTaskState(state, startTest, endTestFirst, addTask, "C");
		createDeadlineTaskState(state, startTest, endTestThird, addTask, "unique");
		
		ArrayList<Task> deadlineTasks = state.getDeadlineTasks();
		assertEquals(endTestFirst, deadlineTasks.get(0).getEndDate());
		assertEquals(endTestSecond, deadlineTasks.get(1).getEndDate());
		assertEquals(endTestThird, deadlineTasks.get(2).getEndDate());
		
		state.setPositionIndex(1);
		assertEquals(false, deadlineTasks.get(0).getIsDetailDisplayed());
		boolean isSuccessful = viewTaskDetail.process();
		assertEquals(true, isSuccessful);
		assertEquals(true, deadlineTasks.get(0).getIsDetailDisplayed());
		isSuccessful = viewTaskDetail.process();
		assertEquals(true, isSuccessful);
		assertEquals(false, deadlineTasks.get(0).getIsDetailDisplayed());

	}
	

	private void createDeadlineTaskState(State state, Date start, Date end, AddTask addTask, String content) {
		state.setIsValid(true);
		state.setIsContentChanged(true);
		state.setContent(content);
		state.setIsVenueChanged(true);
		state.setVenue("");
		state.setIsDetailChanged(true);
		state.setDetail("");
		state.setTaskType(TaskType.DEADLINE);
		state.setIsStartDateChanged(true);
		state.setStartDate(start);
		state.setIsEndDateChanged(true);
		state.setEndDate(end);

		boolean isSuccessful = addTask.process();
		assertEquals(true, isSuccessful);
		assertEquals(ViewMode.DEADLINE, state.getViewMode());			
		// pause to ensure correct ordering by creation time
		pause(100);

	}
	
	private void clearState(State state) {
		//Storage storage = new Storage(state);
	    //state.setNewDirectory("/Users/Boxin_Yang/testing");
	    //storage.executeChangeDirectory();
	    state.getAllTasks().clear();
	    state.getDeadlineTasks().clear();
	    state.getFloatingTasks().clear();
	    state.getFinishedTasks().clear();
	    state.getSearchResultTasks().clear();
	}
	
	private Date stringToDate(String str){
		try {
		    SimpleDateFormat sdf = new SimpleDateFormat("dd MMM y HH:mm");
			Date date;
			date = sdf.parse(str);
			return date;
		} catch (ParseException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
			return null;
		}
	}
	
	private void pause(int timeInterval) {
		try {
			Thread.sleep(timeInterval);
		} catch (InterruptedException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
	}

}

```
