# A0130369H
###### \common\CommandType.java
``` java
package common;

public enum CommandType {
	ADD, UPDATE, DELETE, CLEAR, TICK, ERROR, EXIT, SEARCH, UNDO, REDO, UNDEFINED, DETAIL, CHANGEMODE, UNTICK, CONFIG, HELP;
}
```
###### \common\Constant.java
``` java
package common;

public class Constant {
		
		// List of all available error values for the parser
		public static final String VALUE_ERROR_COMMAND_NOT_FOUND = "Invalid command. Check your command again?";
		public static final String VALUE_ERROR_NO_INPUT = "Empty input";
		public static final String VALUE_ERROR_INVALID_ARGUMENT = "Invalid argument";
		public static final String VALUE_ERROR_ADD_EMPTY = "What do you want to add?";
		public static final String VALUE_ERROR_SEARCH_EMPTY = "What do you want to search?";
		public static final String VALUE_ERROR_UPDATE_WRONG_ARGUMENT = "Your input seems wrong. You may type Help for input format";
		public static final String VALUE_ERROR_INVALID_VIEW_MODE = "We do not have that view mode. Try again?";
		public static final String VALUE_ERROR_INVALID_CONFIG = "We do not have that font or themes. Check for any typos?";
		public static final String VALUE_ERROR_ARGUMENT_NOT_EMPTY = "This command has no argument, remember?";
		public static final String VALUE_ERROR_ARGUMENT_NOT_NUMBER = "Do you put the index correctly?";
		public static final String VALUE_ERROR_DATE_NOT_PARSED = "Wrong date format?";
		public static final String VALUE_ERROR_DATE_ERROR = "Oops, starting date can't be later than end date";
		public static final String VALUE_ERROR_WRONG_FORMAT = "Seems like you put the wrong input format";
		
		//List of all available success message for parser
		public static final String VALUE_SUCCESS_NO_ERROR = "Success";
		public static final String VALUE_SUCCESS_ADD = "A task has been added!";
		public static final String VALUE_SUCCESS_CLEAR = "Tasks have been cleared!";
		public static final String VALUE_SUCCESS_DELETE = "A task has been deleted";
		public static final String VALUE_SUCCESS_UNDO = "Undo";
		public static final String VALUE_SUCCESS_REDO = "Redo";
		public static final String VALUE_SUCCESS_SEARCH = "Searching the keyword...";
		public static final String VALUE_SUCCESS_TICK = "A task has been finished!";
		public static final String VALUE_SUCCESS_UPDATE = "A task has been updated!";
		public static final String VALUE_SUCCESS_DETAIL = "Checking the detail of a task...";
		public static final String VALUE_SUCCESS_VIEW_MODE = "Changing view mode...";
		public static final String VALUE_SUCCESS_HELP = "Here's your help!";
		public static final String VALUE_SUCCESS_CONFIG = "Changing the setting...";
		public static final String VALUE_SUCCESS_UNTICK = "A task has been marked unfinished";
		
		// List of all default values for state
		public static final String VALUE_DEFAULT_EMPTY = "";
		public static final int VALUE_DEFAULT_POSITION_INDEX = 1;
		public static final boolean VALUE_DEFAULT_BOOLEAN_TRUE = true;
		public static final boolean VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_DETAIL_DISPLAYED = true;
		public static final boolean VALUE_DEFAULT_BOOLEAN_IS_NEW_TASK_IMPORTANT = false;
		public static final boolean VALUE_DEFAULT_BOOLEAN_FALSE = false;
		public static final ViewMode VALUE_DEFAULT_VIEW_MODE = ViewMode.START;
		
		//Setting displaying message
		public static final String CONFIG_INTRO = "Welcome to Wallist Setting";
		public static final String CONFIG_DIR = "1. Your current Directory is %s\n" + 
		                                        "You will be able to customize this in our next version";
		public static final String CONFIG_THEME = "2. To change the theme, input the theme name: (E.g. input: theme autumn)";
		public static final String CONFIG_FONT = "3. To change the font, input the font name: (E.g. input: font segoe)";
		
```
###### \common\TaskType.java
``` java
package common;

public enum TaskType {
	FLOATING, DEADLINE, RECURRENT, UNDEFINED
}
```
###### \common\TimeParser.java
``` java
package common;

import com.joestelmach.natty.*;

import java.util.Calendar;
import java.util.Date;
import java.util.List;


public class TimeParser{
 private static com.joestelmach.natty.Parser dateParser = new com.joestelmach.natty.Parser();
 
 public static Date stringToDate(String str){
	 try {
		 Date current = getCurrentDate();
		 List<DateGroup> groups = dateParser.parse(str);
		 Date date = groups.get(0).getDates().get(0);
		 Calendar cal = Calendar.getInstance();
		 Calendar calCurrent = Calendar.getInstance();
		 cal.setTime(date);
		 calCurrent.setTime(current);
		 if(cal.get(Calendar.HOUR_OF_DAY) == calCurrent.get(Calendar.HOUR_OF_DAY) && cal.get(Calendar.MINUTE) == calCurrent.get(Calendar.MINUTE)){
			 cal.set(Calendar.HOUR_OF_DAY, 23);
			 cal.set(Calendar.MINUTE, 59);
			 cal.set(Calendar.SECOND, 59);
		 }
		 
		 
		 return cal.getTime();
	 } catch (Exception e){
		 return null;
	 }
 }
 
 public static Date getCurrentDate(){
	 return Calendar.getInstance().getTime();
 }
}


```
###### \parser\Command.java
``` java
package parser;

import common.State;
import common.TaskType;
import common.ViewMode;

import java.util.ArrayList;
import java.util.Date;

interface Command {
	//====================================
	//       Public Functions
	//====================================
	public void processInput();
	
	//====================================
	//       Helper Functions
	//====================================
	default String getContentWithoutCommand(State state){
		String inputWords[] = state.getUserInput().split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
	
	/**
	 * Check whether the content can be split
	 * @param wordList
	 * @return True if it can't
	 */
	default boolean hasContentSplit(String[] wordList) {
		return wordList.length <= 1;
	}
	
	/**
	 * Split the content using the detail keyword
	 * @param content
	 * @return A list of split content
	 */
	default String[] splitDetail(String content) {
		return content.split("detail:");
	}
	
	default String getFirstWord(String[] wordListVenue) {
		return wordListVenue[0].trim();
	}

	default String getLastWord(String[] wordList) {
		return wordList[wordList.length-1].trim();
	}
	
	default String[] splitVenue(String content) {
		return content.split("at:");
	}
	
	default String[] splitStartDate(String content) {
		return content.split("from:");
	}
	
	default String[] splitEndDateWithStartDate(String endDate) {
		return endDate.split("to:");
	}
	
	default boolean isDateNull(Date date) {
		return date == null;
	}
	

	default String[] splitEndDate(String content) {
		return content.split("on:");
	}
	
	default boolean isContentInvalid(String content) {
		return content.contains("at:") || content.contains("to:") 
				|| content.contains("from:") || content.contains("on:") 
				|| content.contains("detail:");  
		
	}
}
```
###### \parser\CommandAdd.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.TimeParser;
import common.ViewMode;

public class CommandAdd implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandAdd(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		String wordList[] = splitDetail(content_);
		if(hasContentSplit(wordList)){
			state_.setIsDetailChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			// Check if the content has venue specified
			String wordListVenue[] = splitVenue(getLastWord(wordList));
			if(hasContentSplit(wordListVenue)){
				state_.setIsDetailChanged(true);
				return getLastWord(wordList);
			}else{
				state_.setIsDetailChanged(true);
				return getFirstWord(wordListVenue);
			}
		}
	}
	 
	private String getVenue() {
		String wordList[] = splitVenue(content_);
		if(hasContentSplit(wordList)){
			state_.setIsVenueChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			//Check if venue has detail specified
			String wordListDetails[] = splitDetail(getLastWord(wordList));
			if(hasContentSplit(wordListDetails)){
				state_.setIsVenueChanged(true);
				return getLastWord(wordList);
			}else{
				state_.setIsVenueChanged(true);
				return getFirstWord(wordListDetails);
			}
		}
	}
	 
	private Date getStartDate() {
		String wordList[] = splitStartDate(content_);
		if(hasContentSplit(wordList)){
			state_.setIsStartDateChanged(false);
			return null;
		}
		//Check whether has end date specified
		String endDate = getLastWord(wordList);
		String wordListEnd[] = splitEndDateWithStartDate(endDate);
		
		//If not end date specified, don't parse the start date
		if(hasContentSplit(wordListEnd)){
			state_.setIsStartDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
		
		Date date = TimeParser.stringToDate(getFirstWord(wordListEnd));
		if(!isDateNull(date)){
			state_.setIsStartDateChanged(true);
			return date;
		}else{
			state_.setIsStartDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}
	 
	private Date getEndDate() {
		// If has start date
		if(state_.getIsStartDateChanged()){
			String wordList[] = splitEndDateWithStartDate(content_);
			if(hasContentSplit(wordList)){
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
			Date date = TimeParser.stringToDate(getLastWord(wordList));
			if(!isDateNull(date)){
				state_.setIsEndDateChanged(true);
				if(date.before(state_.getStartDate())){
					state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_ERROR);
					state_.setIsValid(false);
					state_.setIsEndDateChanged(false);
					state_.setIsStartDateChanged(false);
					return null;
				}
				return date;
			}else{
				state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
				state_.setIsValid(false);
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
		}
		
		//If don't have start date
		String wordList[] = splitEndDate(content_);
		if(hasContentSplit(wordList)){
			state_.setIsEndDateChanged(false);
			return null;
		}
		Date date = TimeParser.stringToDate(getLastWord(wordList));
		if(!isDateNull(date)){
			state_.setIsEndDateChanged(true);
			return date;
		}else{
			state_.setIsEndDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		// If there is start date
		if(state_.getIsStartDateChanged()){
			String wordList[] = splitStartDate(content_);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return getFirstWord(wordList);
		//If there is only end date
		}else if(state_.getIsEndDateChanged()){
			String wordList[] = splitEndDate(content_);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return getFirstWord(wordList);
			
		//If there is venue
		}else if(state_.getIsVenueChanged()){
			String wordList[] = splitVenue(content_);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			// Check if there is detail
			if(state_.getIsDetailChanged()){
				String wordListDetail[] = splitDetail(getFirstWord(wordList));
				if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
					state_.setIsContentChanged(true);
					return getFirstWord(wordList);
				}else{
					state_.setIsContentChanged(true);
					return getFirstWord(wordListDetail);
				}
			}else{
				state_.setIsContentChanged(true);
				return getFirstWord(wordList);
			}
		//If there is detail
		}else if(state_.getIsDetailChanged()){
			String wordList[] = splitDetail(content_);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
				state_.setIsContentChanged(false);
				state_.setIsValid(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			//Check if there is venue
			if(state_.getIsVenueChanged()){
				String wordListVenue[] = splitVenue(getFirstWord(wordList));
				if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
					state_.setIsContentChanged(true);
					return getFirstWord(wordList);
				}else{
					state_.setIsContentChanged(true);
					return getFirstWord(wordListVenue);
				}
			}else{
				state_.setIsContentChanged(true);
				return getFirstWord(wordList);
			}
		}else{
			if(isContentInvalid(content_)){
				state_.setIsContentChanged(false);
				state_.setDisplayMessage(Constant.VALUE_ERROR_WRONG_FORMAT);
			}else{
				state_.setIsContentChanged(true);
			}
			return content_;
		}
	}


	 
	private TaskType getTaskType() {
		if(state_.getIsEndDateChanged()){
			return TaskType.DEADLINE;
		}else{
			return TaskType.FLOATING;
		}
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
	



}
```
###### \parser\CommandChangeMode.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandChangeMode implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandChangeMode(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		ViewMode viewMode = determineViewMode();
		return viewMode;
	}
	
	/**
	 * Get the view mode based on content
	 * @return ViewMode
	 */
	private ViewMode determineViewMode() {
		if(content_.equalsIgnoreCase("FLOATING")){
			return ViewMode.FLOATING;
		} else if(content_.equalsIgnoreCase("SCHEDULED")){
			return ViewMode.DEADLINE;
		} else if(content_.equalsIgnoreCase("ALL")){
			return ViewMode.ALL;
		} else if(content_.equalsIgnoreCase("SETTING")){
			return ViewMode.CONFIG;
		} else if(content_.equalsIgnoreCase("FINISHED")){
			return ViewMode.FINISHED;
		} else if (content_.equalsIgnoreCase("HELP")) {
			return ViewMode.HELP;
		} else if (content_.equalsIgnoreCase("TODAY")) {
			return ViewMode.START;
		} else {
			return ViewMode.UNDEFINED;
		}
	}
}
```
###### \parser\CommandClear.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandClear implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandClear(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \parser\CommandConfig.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.Font;
import common.State;
import common.TaskType;
import common.Theme;
import common.ViewMode;

public class CommandConfig implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandConfig(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		state_.setNewFont(getFont());
		state_.setNewTheme(getTheme());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(true);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.CONFIG;
	}
	
	private Theme getTheme() {
		if(content_.equalsIgnoreCase("autumn")){
			return Theme.AUTUMN;
		}else if(content_.equalsIgnoreCase("bokeh")){
			return Theme.BOKEH;
		}else if(content_.equalsIgnoreCase("branch")){
			return Theme.BRANCH;
		}else if(content_.equalsIgnoreCase("cat")){
			return Theme.CAT;
		}else if(content_.equalsIgnoreCase("grey")){
			return Theme.GREY;
		}else if(content_.equalsIgnoreCase("warm")){
			return Theme.WARM;
		}else{
			return state_.getTheme();
		}
	}
	private Font getFont() {
		if(content_.equalsIgnoreCase("consolas")){
			return Font.CONSOLAS;
		}else if(content_.equalsIgnoreCase("segoe")){
			return Font.SEGOE;
		}else{
			return state_.getFont();
		}
	}

}
```
###### \parser\CommandDelete.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandDelete implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandDelete(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \parser\CommandDetail.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandDetail implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandDetail(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \parser\CommandHelp.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandHelp implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandHelp(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.HELP;
	}

}
```
###### \parser\CommandRedo.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandRedo implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandRedo(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}
}
```
###### \parser\CommandSearch.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandSearch implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandSearch(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		ArrayList<String> keywords = new ArrayList<String>();
		String inputKeyWords[] = content_.split(" ");
		if(inputKeyWords.length == 0){
			state_.setDisplayMessage(Constant.VALUE_ERROR_SEARCH_EMPTY);
		}
		for(int i = 0; i<inputKeyWords.length; i++){
			keywords.add(inputKeyWords[i]);
		}
		return keywords;
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.SEARCH;
	}

}
```
###### \parser\CommandTick.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandTick implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandTick(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \parser\CommandUndo.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandUndo implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandUndo(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Constant.VALUE_DEFAULT_POSITION_INDEX;
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \parser\CommandUntick.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.ViewMode;

public class CommandUntick implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandUntick(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		state_.setIsDetailChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	private String getVenue() {
		state_.setIsVenueChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	private Date getStartDate() {
		state_.setIsStartDateChanged(false);
		return null;
	}

	 
	private Date getEndDate() {
		state_.setIsEndDateChanged(false);
		return null;
	}

	 
	private int getPositionIndex() {
		return Integer.parseInt(content_);
	}

	 
	private String getContent() {
		state_.setIsContentChanged(false);
		return Constant.VALUE_DEFAULT_EMPTY;
	}

	 
	private TaskType getTaskType() {
		return TaskType.UNDEFINED;
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \parser\CommandUpdate.java
``` java
package parser;

import java.util.ArrayList;
import java.util.Date;

import common.Constant;
import common.State;
import common.TaskType;
import common.TimeParser;
import common.ViewMode;

public class CommandUpdate implements Command{
	//============================
	//       Attributes
	//============================
	private State state_;
	private String content_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	/**
	 * Initialize the command
	 * @param state
	 */
	public CommandUpdate(State state){
		state_ = state;
		content_ = Constant.VALUE_DEFAULT_EMPTY;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Process the input and update the state accordingly
	 */
	@Override
	public void processInput() {
		content_ = getContentWithoutCommand(state_);
		state_.setDetail(getDetail());
		state_.setVenue(getVenue());
		state_.setStartDate(getStartDate());
		state_.setEndDate(getEndDate());
		state_.setPositionIndex(getPositionIndex());
		state_.setContent(getContent());
		state_.setTaskType(getTaskType());
		state_.setSearchKey(getSearchKey());
		state_.setNewViewMode(getNewViewMode());
		
	}

	//====================================
	//       Helper Functions
	//====================================
	/**
	 * The following methods update the state
	 */
	private String getDetail() {
		String content = getContentWithoutIndex();
		String wordList[] = splitDetail(content);
		if(hasContentSplit(wordList)){
			state_.setIsDetailChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			// Check if the content has venue specified
			String wordListVenue[] = splitVenue(getLastWord(wordList));
			if(hasContentSplit(wordListVenue)){
				state_.setIsDetailChanged(true);
				return getLastWord(wordList);
			}else{
				state_.setIsDetailChanged(true);
				return getFirstWord(wordListVenue);
			}
		}
	}
	 
	private String getVenue() {
		String content = getContentWithoutIndex();
		String wordList[] = splitVenue(content);
		if(hasContentSplit(wordList)){
			state_.setIsVenueChanged(false);
			return Constant.VALUE_DEFAULT_EMPTY;
		}else{
			//Check if venue has detail specified
			String wordListDetails[] = splitDetail(getLastWord(wordList));
			if(hasContentSplit(wordListDetails)){
				state_.setIsVenueChanged(true);
				return getLastWord(wordList);
			}else{
				state_.setIsVenueChanged(true);
				return getFirstWord(wordListDetails);
			}
		}
	}

	 
	private Date getStartDate() {
		String wordList[] = splitStartDate(content_);
		if(hasContentSplit(wordList)){
			state_.setIsStartDateChanged(false);
			return null;
		}
		//Check whether has end date specified
		String endDate = getLastWord(wordList);
		String wordListEnd[] = splitEndDateWithStartDate(endDate);
		
		//If not end date specified, don't parse the start date
		if(hasContentSplit(wordListEnd)){
			state_.setIsStartDateChanged(false);
			state_.setIsValid(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			return null;
		}
		Date date = TimeParser.stringToDate(getFirstWord(wordListEnd));
		if(!isDateNull(date)){
			state_.setIsStartDateChanged(true);
			return date;
		}else{
			state_.setIsStartDateChanged(false);
			state_.setIsValid(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			return null;
		}
	}

	 
	private Date getEndDate() {
		// If has start date
		if(state_.getIsStartDateChanged()){
			String wordList[] = splitEndDateWithStartDate(content_);
			if(hasContentSplit(wordList)){
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				return null;
			}
			Date date = TimeParser.stringToDate(getLastWord(wordList));
			if(!isDateNull(date)){
				state_.setIsEndDateChanged(true);
				if(date.before(state_.getStartDate())){
					state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_ERROR);
					state_.setIsValid(false);
					state_.setIsEndDateChanged(false);
					state_.setIsStartDateChanged(false);
					return null;
				}
				return date;
			}else{
				state_.setIsEndDateChanged(false);
				state_.setIsStartDateChanged(false);
				state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
				state_.setIsValid(false);
				return null;
			}
		}
		//If don't have start date
		String wordList[] = splitEndDate(content_);
		if(hasContentSplit(wordList)){
			state_.setIsEndDateChanged(false);
			return null;
		}
		Date date = TimeParser.stringToDate(getLastWord(wordList));
		if(!isDateNull(date)){
			state_.setIsEndDateChanged(true);
			return date;
		}else{
			state_.setIsEndDateChanged(false);
			state_.setDisplayMessage(Constant.VALUE_ERROR_DATE_NOT_PARSED);
			state_.setIsValid(false);
			return null;
		}
	}

	 
	private int getPositionIndex() {
		String wordList[] = content_.split(" ");
		return Integer.parseInt(getFirstWord(wordList));
	}

	 
	private String getContent() {
		String content = getContentWithoutIndex();
		// If there is start date
		if(state_.getIsStartDateChanged()){
			String wordList[] = splitStartDate(content);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return getFirstWord(wordList);
		//If there is only end date
		}else if(state_.getIsEndDateChanged()){
			String wordList[] = splitEndDate(content);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			state_.setIsContentChanged(true);
			return getFirstWord(wordList);
		
		//If there is venue
		}else if(state_.getIsVenueChanged()){
			String wordList[] = splitVenue(content);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			// Check if there is detail
			if(state_.getIsDetailChanged()){
				String wordListDetail[] = splitDetail(getFirstWord(wordList));
				if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
					state_.setIsContentChanged(true);
					return getFirstWord(wordList);
				}else{
					state_.setIsContentChanged(true);
					return getFirstWord(wordListDetail);
				}
			}else{
				state_.setIsContentChanged(true);
				return getFirstWord(wordList);
			}
		//If there is detail
		}else if(state_.getIsDetailChanged()){
			String wordList[] = splitDetail(content);
			if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
				state_.setIsContentChanged(false);
				return Constant.VALUE_DEFAULT_EMPTY;
			}
			//Check if there is venue
			if(state_.getIsVenueChanged()){
				String wordListVenue[] = splitVenue(getFirstWord(wordList));
				if(hasContentSplit(wordList) || getFirstWord(wordList).isEmpty()){
					state_.setIsContentChanged(true);
					return getFirstWord(wordList);
				}else{
					state_.setIsContentChanged(true);
					return getFirstWord(wordListVenue);
				}
			}else{
				state_.setIsContentChanged(true);
				return getFirstWord(wordList);
			}
		}else{
			if(content.trim().isEmpty()){
				state_.setDisplayMessage(Constant.VALUE_ERROR_NO_INPUT);
			}
			if(isContentInvalid(content)){
				state_.setIsContentChanged(false);
				state_.setDisplayMessage(Constant.VALUE_ERROR_WRONG_FORMAT);
			}else{
				state_.setIsContentChanged(true);
			}
			return content;
		}
	}

	/**
	 * Get the content of the input without the index
	 * @return String of the content
	 */
	private String getContentWithoutIndex() {
		String inputWords[] = content_.split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
	
	 
	private TaskType getTaskType() {
		if(state_.getIsEndDateChanged()){
			return TaskType.DEADLINE;
		}else{
			return TaskType.FLOATING;
		}
	}

	 
	private ArrayList<String> getSearchKey() {
		return new ArrayList<String>();
	}
	
	 
	private ViewMode getNewViewMode() {
		return ViewMode.UNDEFINED;
	}

}
```
###### \parser\Parser.java
``` java
package parser;

import common.*;

public class Parser {
	
	//============================
	//       Attributes
	//============================
	
	private State state_;
	private ParserErrorChecker errorChecker_;
	private CommandAdd add_;
	private CommandChangeMode changeMode_;
	private CommandClear clear_;
	private CommandDelete delete_;
	private CommandDetail detail_;
	private CommandExit exit_;
	private CommandRedo redo_;
	private CommandSearch search_;
	private CommandTick tick_;
	private CommandUndo undo_;
	private CommandUpdate update_;
	private CommandHelp help_;
	private CommandUntick untick_;
	private CommandConfig config_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	
 	public Parser(State state){
		state_ = state;
		errorChecker_ = new ParserErrorChecker(state);
		add_ = new CommandAdd(state);
		changeMode_ = new CommandChangeMode(state);
		clear_ = new CommandClear(state);
		delete_ = new CommandDelete(state);
		detail_ = new CommandDetail(state);
		exit_ = new CommandExit(state);
		redo_ = new CommandRedo(state);
		search_ = new CommandSearch(state);
		tick_ = new CommandTick(state);
		undo_ = new CommandUndo(state);
		update_ = new CommandUpdate(state);
		help_ = new CommandHelp(state);
		config_= new CommandConfig(state);
		untick_ = new CommandUntick(state);
		
	}
	
	/**
	 * Break down a string of input into smaller parts for logic to process
	 * Pre-Cond: Input of the user in the state
	 * Post-Cond: Respective command function will process the input
	 */
	public boolean processInput(){

		state_.setContent(state_.getContent().trim());
		errorChecker_.checkError();
		if(state_.getIsValid()){
			CommandType command = state_.getCommandType();
			switch(command){
			case ADD:
				add_.processInput();
				break;
			case CHANGEMODE:
				changeMode_.processInput();
				break;
			case CLEAR:
				clear_.processInput();
				break;
			case DELETE:
				delete_.processInput();
				break;
			case DETAIL:
				detail_.processInput();
				break;	
			case EXIT:
				exit_.processInput();
				break;
			case REDO:
				redo_.processInput();
				break;				
			case SEARCH:
				search_.processInput();
				break;				
			case TICK:
				tick_.processInput();
				break;			
			case UNDO:
    			undo_.processInput();
				break;				
			case UPDATE:
				update_.processInput();
				break;			
			case HELP:
	    		help_.processInput();
				break;				
			case UNTICK:
				untick_.processInput();
				break;					
			case CONFIG:;
				config_.processInput();
				break;
			}		
		}
		return state_.getIsValid();
	}
}
```
###### \parser\ParserErrorChecker.java
``` java
package parser;

import common.CommandType;
import common.Constant;
import common.State;

public class ParserErrorChecker {
	
	//============================
	//       Attributes
	//============================
	private State state_;
	
	//====================================
	//       Constructor and Initialiser
	//====================================
	public ParserErrorChecker(State state){
		state_ = state;
	}
	
	//====================================
	//       Public Functions
	//====================================
	/**
	 * Check whether the content of the input has any error
	 * @return display message
	 * @return the validity of the input
	 */
	public void checkError(){
		state_.setDisplayMessage(getErrorMessage());
		state_.setIsValid(getIsValid());
		if(state_.getIsValid()){
			state_.setCommandType(getCommand());
		}
	}
	
	//====================================
	//       Helper Functions
	//====================================
	/**
	 * Check whether parsed command is valid
	 * @return True if the input is valid
	 */
	private boolean getIsValid() {
		return isTaskValid();
	}

	private boolean isTaskValid() {
		return state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_NO_ERROR)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_ADD)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_UPDATE)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_TICK)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_UNTICK)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_UNDO)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_REDO)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_CLEAR)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_DELETE)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_SEARCH)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_DETAIL)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_VIEW_MODE)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_CONFIG)
				|| state_.getDisplayMessage().equals(Constant.VALUE_SUCCESS_HELP);
	}
	
	/**
	 * Get the error message for a given input. 
	 * @return The respective error message
	 */
	private String getErrorMessage() {
		if(isInputEmpty()){
			return Constant.VALUE_ERROR_NO_INPUT;
		}
		if(isCommandInvalid()){
			return Constant.VALUE_ERROR_COMMAND_NOT_FOUND;
		}
		return checkInvalidArgument();
	}

	/**
	 * Check whether the input is an empty string
	 * @return True if it's empty input
	 */	
	private boolean isInputEmpty() {
		return state_.getUserInput().length() == 0;
	}
	
	/**
	 * Check whether the input has a valid command (add, update, tick, delete, clear, exit, etc)
	 * @return True if the command is invalid
	 */
	private boolean isCommandInvalid() {
		if(!isInputEmpty()){
			CommandType commandType = getCommand();
			switch(commandType) {
				case ADD:
					return false;
					
				case CLEAR:
					return false;
					
				case DELETE:
					return false;
					
				case TICK:
					return false;	
					
				case UPDATE:
					return false;
					
				case EXIT:
					return false;
					
				case UNDO:
					return false;
				
				case REDO:
					return false;
					
				case CHANGEMODE:
					return false;	
					
				case SEARCH: 
					return false;
				
				case DETAIL:
					return false;
					
				case HELP:
					return false;

				case UNTICK:
					return false;
				
				case CONFIG:
					return false;
					
				default: 
					return true;
			}
		}
		return false;
	}
	
	/**
	 * Check whether the input has the correct and valid argument for the given command
	 * @return respective error message
	 */
	private String checkInvalidArgument() {
		if(!isCommandInvalid()){
			CommandType commandType = getCommand();
			String content = getContentWithoutCommand();
			try{
				switch(commandType){
				
					case ADD:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_ADD_EMPTY;
						}
						return Constant.VALUE_SUCCESS_ADD;
					
					case CLEAR:
						if(isContentEmpty(content)){
							return Constant.VALUE_SUCCESS_CLEAR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
				
					case DELETE:
						if(isContentNumber(content)){
							return Constant.VALUE_SUCCESS_DELETE;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
				
					case EXIT:
						if(isContentEmpty(content)){
							return Constant.VALUE_SUCCESS_NO_ERROR;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
					
					case UNDO:
						if(isContentEmpty(content)){
							return Constant.VALUE_SUCCESS_UNDO;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
					
					case REDO:
						if(isContentEmpty(content)){
							return Constant.VALUE_SUCCESS_REDO;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
						
					case SEARCH:
						if(isContentEmpty(content)){
							return Constant.VALUE_ERROR_SEARCH_EMPTY;
						}
						return Constant.VALUE_SUCCESS_SEARCH;
						
					case TICK:
						if(isContentNumber(content)){
							return Constant.VALUE_SUCCESS_TICK;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
					
					case UPDATE:
						String inputWords[] = content.split(" ");
						if(!isContentNumber(inputWords[0]) || isContentEmpty(content) || hasContentOneArgument(inputWords)){
							return Constant.VALUE_ERROR_UPDATE_WRONG_ARGUMENT;
						}
						return Constant.VALUE_SUCCESS_UPDATE;
					
					case DETAIL:
						if(isContentNumber(content)){
							return Constant.VALUE_SUCCESS_DETAIL;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
					
					case CHANGEMODE:
						if(isContentValidViewMode(content)){
							return Constant.VALUE_SUCCESS_VIEW_MODE;
						}
						return Constant.VALUE_ERROR_INVALID_VIEW_MODE;
					
					case HELP:
						if(isContentEmpty(content)){
							return Constant.VALUE_SUCCESS_HELP;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_EMPTY;
					
					case CONFIG:
						if(isContentValidFontOrTheme(content)){
							return Constant.VALUE_SUCCESS_CONFIG;
						}else{
							return Constant.VALUE_ERROR_INVALID_CONFIG;
						}
					case UNTICK:
						if(isContentNumber(content)){
							return Constant.VALUE_SUCCESS_UNTICK;
						}
						return Constant.VALUE_ERROR_ARGUMENT_NOT_NUMBER;
						
					default: 
						return Constant.VALUE_SUCCESS_NO_ERROR;
				}
			}
			catch(IllegalArgumentException e){
				return Constant.VALUE_ERROR_INVALID_ARGUMENT;
			}
		}else{
			return Constant.VALUE_ERROR_COMMAND_NOT_FOUND;
		}
	}
	
	/**
	 * Check if content is a valid theme or font
	 * @return True if it is
	 */
	private boolean isContentValidFontOrTheme(String content) {
		return content.equalsIgnoreCase("CONSOLAS") || content.equalsIgnoreCase("SEGOE")
			|| content.equalsIgnoreCase("AUTUMN") || content.equalsIgnoreCase("BOKEH")
			|| content.equalsIgnoreCase("BRANCH") || content.equalsIgnoreCase("CAT")
			|| content.equalsIgnoreCase("GREY") || content.equalsIgnoreCase("WARM");
	}
	
	/**
	 * Check if the content is a valid viewmode
	 * @return True if it is
	 */
	private boolean isContentValidViewMode(String content) {
		return content.equalsIgnoreCase("FLOATING") || content.equalsIgnoreCase("SCHEDULED") 
				|| content.equalsIgnoreCase("ALL") || content.equalsIgnoreCase("FINISHED") 
				|| content.equalsIgnoreCase("SETTING") || content.equalsIgnoreCase("TODAY");
	}
	
	/**
	 * Check whether the content has the required index and update content
	 * @return true if it has one argument only
	 */
	private boolean hasContentOneArgument(String[] inputWords) {
		return inputWords.length ==1;
	}
	
	/**
	 * Check if the content is a number
	 * @return true if it is
	 */
	private boolean isContentNumber(String content) {
		return content.matches("\\d+");
	}

	/**
	 * Check whether the content is empty
	 * @return true if it is empty
	 */
	private boolean isContentEmpty(String content) {
		return content.isEmpty();
	}


	/**
	 * Get the content of user input without the command word
	 * @return the user input without the command word
	 */
	private String getContentWithoutCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		StringBuilder sb = new StringBuilder("");
		for(int i = 1; i < inputWords.length; i ++){
			sb.append(inputWords[i]);
			sb.append(" ");
		}
		return sb.toString().trim();
	}
	/**
	 * Get the command of an input
	 * @param Input of the user
	 * @return The command type
	 */
	private CommandType getCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		return determineCommandType(inputWords[0]);
	}

	
	/**
	 * Get the command type based on input
	 * @param String of the command
	 * @return CommandType of the command
	 */
	private CommandType determineCommandType(String commandTypeString) {
		if (commandTypeString == null) {
			throw new Error("Command type string cannot be null!");
		}
		
		if (commandTypeString.equalsIgnoreCase("add")) {
			return CommandType.ADD;
		} else if (commandTypeString.equalsIgnoreCase("delete")) {
			return CommandType.DELETE;
		} else if (commandTypeString.equalsIgnoreCase("update")) {
			return CommandType.UPDATE;
		} else if (commandTypeString.equalsIgnoreCase("clear")) {
			return CommandType.CLEAR;
		} else if (commandTypeString.equalsIgnoreCase("tick")) {
			return CommandType.TICK;
		} else if (commandTypeString.equalsIgnoreCase("undo")) {
			return CommandType.UNDO;
		} else if (commandTypeString.equalsIgnoreCase("redo")) {
			return CommandType.REDO;
		} else if (commandTypeString.equalsIgnoreCase("search")) {
			return CommandType.SEARCH;
		} else if (commandTypeString.equalsIgnoreCase("exit")) {
			return CommandType.EXIT;
		}  else if (commandTypeString.equalsIgnoreCase("help") || commandTypeString.equalsIgnoreCase("?")) {
			return CommandType.HELP;
		}  else if (commandTypeString.equalsIgnoreCase("untick")) {
			return CommandType.UNTICK;
		} else if (commandTypeString.equalsIgnoreCase("setting")) {
			return CommandType.CONFIG;
		}else if (commandTypeString.equalsIgnoreCase("view")) {
			return getViewCommand();
		}
		return CommandType.ERROR;
	}
	
	/**
	 * Check whether it is a detail command or a changemode command
	 */
	private CommandType getViewCommand() {
		String inputWords[] = state_.getUserInput().split(" ");
		String argument = inputWords[1];
		if(isContentNumber(argument)){
			return CommandType.DETAIL;
		}else{
			return CommandType.CHANGEMODE;
		}
	}
}
```
